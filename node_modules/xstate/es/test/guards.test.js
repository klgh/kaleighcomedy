var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
import { assert } from 'chai';
import { Machine } from '../src/index';
describe('guard conditions', function () {
    // type LightMachineEvents =
    //   | { type: 'TIMER'; elapsed: number }
    //   | { type: 'EMERGENCY'; isEmergency: boolean };
    var lightMachine = Machine({
        key: 'light',
        initial: 'green',
        states: {
            green: {
                on: {
                    TIMER: [{
                        target: 'green',
                        cond: function (_a) {
                            var elapsed = _a.elapsed;
                            return elapsed < 100;
                        }
                    }, {
                        target: 'yellow',
                        cond: function (_a) {
                            var elapsed = _a.elapsed;
                            return elapsed >= 100 && elapsed < 200;
                        }
                    }],
                    EMERGENCY: {
                        target: 'red',
                        cond: function (_, event) {
                            return event.isEmergency;
                        }
                    }
                }
            },
            yellow: {
                on: {
                    TIMER: {
                        target: 'red',
                        cond: 'minTimeElapsed'
                    },
                    TIMER_COND_OBJ: {
                        target: 'red',
                        cond: {
                            type: 'minTimeElapsed'
                        }
                    }
                }
            },
            red: {
                on: {
                    BAD_COND: { target: 'red', cond: 'doesNotExist' }
                }
            }
        }
    }, {
        guards: {
            minTimeElapsed: function (_a) {
                var elapsed = _a.elapsed;
                return elapsed >= 100 && elapsed < 200;
            }
        }
    });
    it('should transition only if condition is met', function () {
        assert.equal(lightMachine.transition('green', 'TIMER', {
            elapsed: 50
        }).value, 'green');
        assert.deepEqual(lightMachine.transition('green', 'TIMER', {
            elapsed: 120
        }).value, 'yellow');
    });
    it('should transition if condition based on event is met', function () {
        assert.deepEqual(lightMachine.transition('green', { type: 'EMERGENCY', isEmergency: true }).value, 'red');
    });
    it('should not transition if condition based on event is not met', function () {
        assert.deepEqual(lightMachine.transition('green', { type: 'EMERGENCY' }).value, 'green');
    });
    it('should not transition if no condition is met', function () {
        var nextState = lightMachine.transition('green', 'TIMER', {
            elapsed: 9000
        });
        assert.deepEqual(nextState.value, 'green');
        assert.isEmpty(nextState.actions);
    });
    it('should work with defined string transitions', function () {
        var nextState = lightMachine.transition('yellow', 'TIMER', {
            elapsed: 150
        });
        assert.equal(nextState.value, 'red');
    });
    it('should work with guard objects', function () {
        var nextState = lightMachine.transition('yellow', 'TIMER_COND_OBJ', {
            elapsed: 150
        });
        assert.equal(nextState.value, 'red');
    });
    it('should work with defined string transitions (condition not met)', function () {
        var nextState = lightMachine.transition('yellow', 'TIMER', {
            elapsed: 10
        });
        assert.equal(nextState.value, 'yellow');
    });
    it('should throw if string transition is not defined', function () {
        assert.throws(function () {
            return lightMachine.transition('red', 'BAD_COND');
        });
    });
});
describe('guard conditions', function () {
    var machine = Machine({
        key: 'microsteps',
        type: 'parallel',
        states: {
            A: {
                initial: 'A0',
                states: {
                    A0: {
                        on: {
                            A: 'A1'
                        }
                    },
                    A1: {
                        on: {
                            A: 'A2'
                        }
                    },
                    A2: {
                        on: {
                            A: 'A3'
                        }
                    },
                    A3: {
                        on: {
                            '': 'A4'
                        }
                    },
                    A4: {
                        on: {
                            '': 'A5'
                        }
                    },
                    A5: {}
                }
            },
            B: {
                initial: 'B0',
                states: {
                    B0: {
                        on: {
                            T1: [{
                                target: 'B1',
                                cond: function (_state, _event, _a) {
                                    var s = _a.state;
                                    return s.matches('A.A1');
                                }
                            }],
                            T2: [{
                                target: 'B2',
                                cond: function (_state, _event, _a) {
                                    var s = _a.state;
                                    return s.matches('A.A2');
                                }
                            }],
                            T3: [{
                                target: 'B3',
                                cond: function (_state, _event, _a) {
                                    var s = _a.state;
                                    return s.matches('A.A3');
                                }
                            }],
                            '': [{
                                target: 'B4',
                                cond: function (_state, _event, _a) {
                                    var s = _a.state;
                                    return s.matches('A.A4');
                                }
                            }]
                        }
                    },
                    B1: {},
                    B2: {},
                    B3: {},
                    B4: {}
                }
            }
        }
    });
    it('should guard against transition', function () {
        assert.deepEqual(machine.transition({ A: 'A2', B: 'B0' }, 'T1').value, {
            A: 'A2',
            B: 'B0'
        });
    });
    it('should allow a matching transition', function () {
        assert.deepEqual(machine.transition({ A: 'A2', B: 'B0' }, 'T2').value, {
            A: 'A2',
            B: 'B2'
        });
    });
    it('should check guards with interim states', function () {
        assert.deepEqual(machine.transition({ A: 'A2', B: 'B0' }, 'A').value, {
            A: 'A5',
            B: 'B4'
        });
    });
});
describe('custom guards', function () {
    var machine = Machine({
        id: 'custom',
        initial: 'inactive',
        context: {
            count: 0
        },
        states: {
            inactive: {
                on: {
                    EVENT: {
                        target: 'active',
                        cond: {
                            type: 'custom',
                            prop: 'count',
                            op: 'greaterThan',
                            compare: 3
                        }
                    }
                }
            },
            active: {}
        }
    }, {
        guards: {
            custom: function (ctx, e, meta) {
                var _a = meta.cond,
                    prop = _a.prop,
                    compare = _a.compare,
                    op = _a.op; // TODO: fix
                if (op === 'greaterThan') {
                    return ctx[prop] + e.value > compare;
                }
                return false;
            }
        }
    });
    it('should evaluate custom guards', function () {
        var passState = machine.transition(machine.initialState, {
            type: 'EVENT',
            value: 4
        });
        assert.equal(passState.value, 'active');
        var failState = machine.transition(machine.initialState, {
            type: 'EVENT',
            value: 3
        });
        assert.equal(failState.value, 'inactive');
    });
});
describe('referencing guards', function () {
    var stringGuardFn = function () {
        return true;
    };
    var guardsMachine = Machine({
        id: 'guards',
        initial: 'active',
        states: {
            active: {
                on: {
                    EVENT: [{ cond: 'string' }, {
                        cond: function guardFn() {
                            return true;
                        }
                    }, {
                        cond: {
                            type: 'object',
                            foo: 'bar'
                        }
                    }]
                }
            }
        }
    }, {
        guards: {
            string: stringGuardFn
        }
    });
    var def = guardsMachine.definition;
    var _a = __read(def.states.active.on.EVENT, 3),
        stringGuard = _a[0],
        functionGuard = _a[1],
        objectGuard = _a[2];
    it('guard predicates should be able to be referenced from a string', function () {
        assert.isDefined(stringGuard.cond.predicate);
        assert.equal(stringGuard.cond.name, 'string');
    });
    it('guard predicates should be able to be referenced from a function', function () {
        assert.isDefined(functionGuard.cond.predicate);
        assert.deepEqual(functionGuard.cond.name, 'guardFn');
    });
    it('guard predicates should be able to be referenced from an object', function () {
        assert.isDefined(objectGuard.cond);
        assert.deepEqual(objectGuard.cond, {
            type: 'object',
            foo: 'bar'
        });
    });
    it('should throw for guards with missing predicates', function () {
        var machine = Machine({
            id: 'invalid-predicate',
            initial: 'active',
            states: {
                active: {
                    on: {
                        EVENT: { target: 'inactive', cond: 'missing-predicate' }
                    }
                },
                inactive: {}
            }
        });
        assert.throws(function () {
            machine.transition(machine.initialState, 'EVENT');
        }, "Unable to evaluate guard");
    });
});
//# sourceMappingURL=guards.test.js.map