var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function (thisArg, body) {
    var _ = { label: 0, sent: function () {
            if (t[0] & 1) throw t[1];return t[1];
        }, trys: [], ops: [] },
        f,
        y,
        t,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0:case 1:
                    t = op;break;
                case 4:
                    _.label++;return { value: op[1], done: false };
                case 5:
                    _.label++;y = op[1];op = [0];continue;
                case 7:
                    op = _.ops.pop();_.trys.pop();continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];t = op;break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];_.ops.push(op);break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [6, e];y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
import { assert } from 'chai';
// import { Element as XMLElement } from 'xml-js';
import * as fs from 'fs';
import * as path from 'path';
// import * as util from 'util';
import { toMachine } from '../src/scxml';
import { interpret } from '../src/interpreter';
import { SimulatedClock } from '../src/SimulatedClock';
import { pathsToStateValue } from '../src/utils';
// import { StateValue } from '../src/types';
// import { Event, StateValue, ActionObject } from '../src/types';
// import { actionTypes } from '../src/actions';
var testGroups = {
    actionSend: ['send1', 'send2', 'send3', 'send4', 'send7', 'send8'
    // 'send9' // - edge case, since initial transitions in xstate are not microstepped
    ],
    'assign-current-small-step': ['test0', 'test1', 'test2', 'test3', 'test4'],
    basic: ['basic1', 'basic2'],
    'cond-js': ['test0', 'test1', 'test2', 'TestConditionalTransition'],
    data: [],
    'default-initial-state': ['initial1', 'initial2'],
    delayedSend: ['send1', 'send2', 'send3'],
    documentOrder: ['documentOrder0'],
    error: [],
    forEach: [],
    hierarchy: ['hier0', 'hier1', 'hier2'],
    'hierarchy+documentOrder': ['test0', 'test1'],
    history: ['history0', 'history1', 'history2', 'history3',
    // 'history4', // TODO: support history nodes on parallel states
    'history5', 'history6'],
    misc: ['deep-initial'],
    'more-parallel': ['test0', 'test1', 'test2',
    // 'test3',
    'test4', 'test5',
    // 'test6',
    'test7', 'test8', 'test9'
    // 'test10'
    ],
    parallel: ['test0', 'test1', 'test2', 'test3'],
    'targetless-transition': ['test0', 'test1', 'test2', 'test3'],
    // 'parallel+interrupt': [
    //   'test0',
    //   'test1',
    //   'test2',
    //   'test3',
    //   'test4',
    //   'test5',
    //   'test6',
    //   'test7',
    //   'test8',
    //   'test9',
    //   'test10',
    //   'test11',
    //   'test12',
    //   'test13',
    //   'test14',
    //   'test15',
    //   'test16',
    //   'test17',
    //   'test18',
    //   'test19',
    //   'test20',
    //   'test21',
    //   'test22',
    //   'test23',
    //   'test24',
    //   'test25',
    //   'test26',
    //   'test27',
    //   'test28',
    //   'test29',
    //   'test30',
    //   'test31'
    // ],
    'w3c-ecma': ['test144.txml']
};
var overrides = {
    'assign-current-small-step': ['test0'],
    'targetless-transition': ['test0']
};
function runW3TestToCompletion(machine) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    return [4 /*yield*/, new Promise(function (res) {
                        interpret(machine).onDone(res).start();
                    })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function runTestToCompletion(machine, test) {
    return __awaiter(this, void 0, void 0, function () {
        var resolvedStateValue, nextState, service;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(!test.events.length && test.initialConfiguration[0] === 'pass')) return [3 /*break*/, 2];
                    return [4 /*yield*/, runW3TestToCompletion(machine)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
                case 2:
                    resolvedStateValue = machine.resolve(pathsToStateValue(test.initialConfiguration.map(function (id) {
                        return machine.getStateNodeById(id).path;
                    })));
                    nextState = machine.getInitialState(resolvedStateValue);
                    service = interpret(machine, {
                        clock: new SimulatedClock()
                    }).onTransition(function (state) {
                        nextState = state;
                    }).start(nextState);
                    test.events.forEach(function (_a, i) {
                        var event = _a.event,
                            nextConfiguration = _a.nextConfiguration,
                            after = _a.after;
                        if (after) {
                            service.clock.increment(after);
                        }
                        service.send(event.name);
                        var stateIds = machine.getStateNodes(nextState).map(function (stateNode) {
                            return stateNode.id;
                        });
                        assert.include(stateIds, nextConfiguration[0], "run " + i);
                    });
                    return [2 /*return*/];
            }
        });
    });
}
function evalCond(expr, context) {
    var literalKeyExprs = context ? Object.keys(context).map(function (key) {
        return "const " + key + " = xs['" + key + "'];";
    }).join('\n') : '';
    var fn = new Function("const xs = arguments[0]; " + literalKeyExprs + " return " + expr);
    return fn;
}
describe('scxml', function () {
    var testGroupKeys = Object.keys(testGroups);
    // const testGroupKeys = ['history'];
    testGroupKeys.forEach(function (testGroupName) {
        testGroups[testGroupName].forEach(function (testName) {
            var scxmlSource = overrides[testGroupName] && overrides[testGroupName].indexOf(testName) !== -1 ? "./fixtures/scxml/" + testGroupName + "/" + testName + ".scxml" : "../node_modules/scxml-test-framework/test/" + testGroupName + "/" + testName + ".scxml";
            var scxmlDefinition = fs.readFileSync(path.resolve(__dirname, scxmlSource), { encoding: 'utf-8' });
            var scxmlTest = JSON.parse(fs.readFileSync(path.resolve(__dirname, "../node_modules/scxml-test-framework/test/" + testGroupName + "/" + testName + ".json"), { encoding: 'utf-8' }));
            it(testGroupName + "/" + testName, function () {
                return __awaiter(_this, void 0, void 0, function () {
                    var machine;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                machine = toMachine(scxmlDefinition, {
                                    evalCond: evalCond,
                                    delimiter: '$'
                                });
                                // console.dir(machine.config, { depth: null });
                                return [4 /*yield*/, runTestToCompletion(machine, scxmlTest)];
                            case 1:
                                // console.dir(machine.config, { depth: null });
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
        });
    });
});
//# sourceMappingURL=scxml.test.js.map