import { assert } from 'chai';
import { Machine, State } from '../src/index';
import { initEvent, assign } from '../src/actions';
var machine = /*#__PURE__*/Machine({
    initial: 'one',
    states: {
        one: {
            onEntry: ['enter'],
            on: {
                EXTERNAL: {
                    target: 'one',
                    internal: false
                },
                INERT: {
                    target: 'one',
                    internal: true
                },
                INTERNAL: {
                    target: 'one',
                    internal: true,
                    actions: ['doSomething']
                },
                TO_TWO: 'two',
                TO_THREE: 'three',
                FORBIDDEN_EVENT: undefined
            }
        },
        two: {
            initial: 'deep',
            states: {
                deep: {
                    initial: 'foo',
                    states: {
                        foo: {
                            on: {
                                FOO_EVENT: 'bar',
                                FORBIDDEN_EVENT: undefined
                            }
                        },
                        bar: {
                            on: {
                                BAR_EVENT: 'foo'
                            }
                        }
                    }
                }
            },
            on: {
                DEEP_EVENT: '.'
            }
        },
        three: {
            type: 'parallel',
            states: {
                first: {
                    initial: 'p31',
                    states: {
                        p31: {
                            on: { P31: '.' }
                        }
                    }
                },
                second: {
                    initial: 'p32',
                    states: {
                        p32: {
                            on: { P32: '.' }
                        }
                    }
                }
            },
            on: {
                THREE_EVENT: '.'
            }
        }
    },
    on: {
        MACHINE_EVENT: '.two'
    }
});
describe('State', function () {
    describe('.changed', function () {
        it('should indicate that it is not changed if initial state', function () {
            assert.isUndefined(machine.initialState.changed);
        });
        it('states from external transitions with onEntry actions should be changed', function () {
            var changedState = machine.transition(machine.initialState, 'EXTERNAL');
            assert.isTrue(changedState.changed, 'changed due to onEntry action');
        });
        it('states from internal transitions with no actions should be unchanged', function () {
            var changedState = machine.transition(machine.initialState, 'EXTERNAL');
            var unchangedState = machine.transition(changedState, 'INERT');
            assert.isFalse(unchangedState.changed, 'unchanged - same state, no actions');
        });
        it('states from internal transitions with actions should be changed', function () {
            var changedState = machine.transition(machine.initialState, 'INTERNAL');
            assert.isTrue(changedState.changed, 'changed - transition actions');
        });
        it('normal state transitions should be changed (initial state)', function () {
            var changedState = machine.transition(machine.initialState, 'TO_TWO');
            assert.isTrue(changedState.changed, 'changed - different state (from initial)');
        });
        it('normal state transitions should be changed', function () {
            var twoState = machine.transition(machine.initialState, 'TO_TWO');
            var changedState = machine.transition(twoState, 'FOO_EVENT');
            assert.isTrue(changedState.changed, 'changed - different state');
        });
        it('normal state transitions with unknown event should be unchanged', function () {
            var twoState = machine.transition(machine.initialState, 'TO_TWO');
            var changedState = machine.transition(twoState, 'UNKNOWN_EVENT');
            assert.isFalse(changedState.changed, 'not changed - unknown event');
        });
        it('should report entering a final state as changed', function () {
            var finalMachine = Machine({
                id: 'final',
                initial: 'one',
                states: {
                    one: {
                        on: {
                            DONE: 'two'
                        }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            var twoState = finalMachine.transition('one', 'DONE');
            assert.isTrue(twoState.changed);
        });
        it('should report any internal transition assignments as changed', function () {
            var assignMachine = Machine({
                id: 'assign',
                initial: 'same',
                context: {
                    count: 0
                },
                states: {
                    same: {
                        on: {
                            EVENT: {
                                actions: assign({ count: function (ctx) {
                                        return ctx.count + 1;
                                    } })
                            }
                        }
                    }
                }
            });
            var initialState = assignMachine.initialState;
            var changedState = assignMachine.transition(initialState, 'EVENT');
            assert.isTrue(changedState.changed);
            assert.deepEqual(initialState.value, changedState.value);
        });
        it('should not escape targetless child state nodes', function () {
            var toggleMachine = Machine({
                id: 'input',
                context: { value: '' },
                type: 'parallel',
                states: {
                    edit: {
                        on: {
                            CHANGE: {
                                actions: assign({
                                    value: function (_, e) {
                                        return e.value;
                                    }
                                })
                            }
                        }
                    },
                    validity: {
                        initial: 'invalid',
                        states: {
                            invalid: {},
                            valid: {}
                        },
                        on: {
                            CHANGE: [{ target: '.valid', cond: function () {
                                    return true;
                                } }, { target: '.invalid' }]
                        }
                    }
                }
            });
            var nextState = toggleMachine.transition(toggleMachine.initialState, {
                type: 'CHANGE',
                value: 'whatever'
            });
            assert.isTrue(nextState.changed);
            assert.deepEqual(nextState.value, {
                edit: {},
                validity: 'valid'
            });
        });
    });
    describe('.nextEvents', function () {
        it('returns the next possible events for the current state', function () {
            assert.deepEqual(machine.initialState.nextEvents, ['EXTERNAL', 'INERT', 'INTERNAL', 'TO_TWO', 'TO_THREE', 'MACHINE_EVENT']);
            assert.deepEqual(machine.transition(machine.initialState, 'TO_TWO').nextEvents, ['FOO_EVENT', 'DEEP_EVENT', 'MACHINE_EVENT']);
            assert.deepEqual(machine.transition(machine.initialState, 'TO_THREE').nextEvents, ['P31', 'P32', 'THREE_EVENT', 'MACHINE_EVENT']);
        });
        it('returns events when transitioned from StateValue', function () {
            var A = machine.transition(machine.initialState, 'TO_THREE');
            var B = machine.transition(A.value, 'TO_THREE');
            assert.deepEqual(B.nextEvents, ['P31', 'P32', 'THREE_EVENT', 'MACHINE_EVENT']);
        });
        it('returns no next events if there are none', function () {
            var noEventsMachine = Machine({
                id: 'no-events',
                initial: 'idle',
                states: {
                    idle: {
                        on: {}
                    }
                }
            });
            assert.isEmpty(noEventsMachine.initialState.nextEvents);
        });
    });
    describe('State.create()', function () {
        it('should be able to create a state from a JSON config', function () {
            var initialState = machine.initialState;
            var jsonInitialState = JSON.parse(JSON.stringify(initialState));
            var stateFromConfig = State.create(jsonInitialState);
            assert.deepEqual(machine.transition(stateFromConfig, 'TO_TWO').value, {
                two: { deep: 'foo' }
            });
        });
    });
    describe('State.inert()', function () {
        it('should create an inert instance of the given State', function () {
            var initialState = machine.initialState;
            assert.isEmpty(State.inert(initialState, undefined).actions);
        });
        it('should create an inert instance of the given stateValue and context', function () {
            var initialState = machine.initialState;
            var inertState = State.inert(initialState.value, { foo: 'bar' });
            assert.isEmpty(inertState.actions);
            assert.deepEqual(inertState.context, { foo: 'bar' });
        });
        it('should preserve the given State if there are no actions', function () {
            var naturallyInertState = State.from('foo');
            assert.equal(State.inert(naturallyInertState, undefined), naturallyInertState);
        });
    });
    describe('.inert', function () {
        it('should create an inert instance of the current State', function () {
            var initialState = machine.initialState;
            assert.isEmpty(initialState.inert.actions);
        });
    });
    describe('.event', function () {
        it('the .event prop should be the event (string) that caused the transition', function () {
            var initialState = machine.initialState;
            var nextState = machine.transition(initialState, 'TO_TWO');
            assert.deepEqual(nextState.event, { type: 'TO_TWO' });
        });
        it('the .event prop should be the event (object) that caused the transition', function () {
            var initialState = machine.initialState;
            var nextState = machine.transition(initialState, {
                type: 'TO_TWO',
                foo: 'bar'
            });
            assert.deepEqual(nextState.event, { type: 'TO_TWO', foo: 'bar' });
        });
        it('the .event prop should be the initial event for the initial state', function () {
            var initialState = machine.initialState;
            assert.deepEqual(initialState.event, initEvent);
        });
    });
    describe('State.prototype.matches', function () {
        it('should keep reference to state instance after destcurting', function () {
            var initialState = machine.initialState;
            var matches = initialState.matches;
            assert.isTrue(matches('one'));
        });
    });
    describe('State.prototype.toStrings', function () {
        it('should return all state paths as strings', function () {
            var twoState = machine.transition('one', 'TO_TWO');
            assert.sameMembers(twoState.toStrings(), ['two', 'two.deep', 'two.deep.foo']);
        });
        it('should keep reference to state instance after destructuring', function () {
            var initialState = machine.initialState;
            var toStrings = initialState.toStrings;
            assert.deepEqual(toStrings(), ['one']);
        });
    });
});
//# sourceMappingURL=state.test.js.map