var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function (thisArg, body) {
    var _ = { label: 0, sent: function () {
            if (t[0] & 1) throw t[1];return t[1];
        }, trys: [], ops: [] },
        f,
        y,
        t,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0:case 1:
                    t = op;break;
                case 4:
                    _.label++;return { value: op[1], done: false };
                case 5:
                    _.label++;y = op[1];op = [0];continue;
                case 7:
                    op = _.ops.pop();_.trys.pop();continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];t = op;break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];_.ops.push(op);break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [6, e];y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
import { Machine, interpret, assign, sendParent, send } from '../src/index';
import { assert } from 'chai';
import { actionTypes, doneInvoke } from '../src/actions';
import { interval } from 'rxjs';
import { map, take } from 'rxjs/operators';
var user = { name: 'David' };
var fetchMachine = /*#__PURE__*/Machine({
    id: 'fetch',
    context: {
        userId: undefined
    },
    initial: 'pending',
    states: {
        pending: {
            onEntry: /*#__PURE__*/send({ type: 'RESOLVE', user: user }),
            on: {
                RESOLVE: {
                    target: 'success',
                    cond: function (ctx) {
                        return ctx.userId !== undefined;
                    }
                }
            }
        },
        success: {
            type: 'final',
            data: { user: function (_, e) {
                    return e.user;
                } }
        },
        failure: {
            onEntry: /*#__PURE__*/sendParent('REJECT')
        }
    }
});
var fetcherMachine = /*#__PURE__*/Machine({
    id: 'fetcher',
    initial: 'idle',
    context: {
        selectedUserId: '42',
        user: undefined
    },
    states: {
        idle: {
            on: {
                GO_TO_WAITING: 'waiting',
                GO_TO_WAITING_MACHINE: 'waitingInvokeMachine'
            }
        },
        waiting: {
            invoke: {
                src: fetchMachine,
                data: {
                    userId: function (ctx) {
                        return ctx.selectedUserId;
                    }
                },
                onDone: {
                    target: 'received',
                    cond: function (_, e) {
                        // Should receive { user: { name: 'David' } } as event data
                        return e.data.user.name === 'David';
                    }
                }
            }
        },
        waitingInvokeMachine: {
            invoke: {
                src: /*#__PURE__*/fetchMachine.withContext({ userId: '55' }),
                onDone: 'received'
            }
        },
        received: {
            type: 'final'
        }
    }
});
// @ts-ignore
var intervalMachine = /*#__PURE__*/Machine({
    id: 'interval',
    initial: 'counting',
    context: {
        interval: 10,
        count: 0
    },
    states: {
        counting: {
            invoke: {
                id: 'intervalService',
                src: function (ctx) {
                    return function (cb) {
                        var ivl = setInterval(function () {
                            cb('INC');
                        }, ctx.interval);
                        return function () {
                            return clearInterval(ivl);
                        };
                    };
                }
            },
            on: {
                '': {
                    target: 'finished',
                    cond: function (ctx) {
                        return ctx.count === 3;
                    }
                },
                INC: { actions: /*#__PURE__*/assign({ count: function (ctx) {
                            return ctx.count + 1;
                        } }) },
                SKIP: 'wait'
            }
        },
        wait: {
            on: {
                // this should never be called if interval service is properly disposed
                INC: { actions: /*#__PURE__*/assign({ count: function (ctx) {
                            return ctx.count + 1;
                        } }) }
            },
            after: {
                50: 'finished'
            }
        },
        finished: {
            type: 'final'
        }
    }
});
describe('invoke', function () {
    it('should start services (external machines)', function (done) {
        var childMachine = Machine({
            id: 'child',
            initial: 'init',
            states: {
                init: {
                    onEntry: [sendParent('INC'), sendParent('INC')]
                }
            }
        });
        var someParentMachine = Machine({
            id: 'parent',
            context: { count: 0 },
            initial: 'start',
            states: {
                start: {
                    invoke: {
                        src: 'child',
                        id: 'someService',
                        autoForward: true
                    },
                    on: {
                        INC: { actions: assign({ count: function (ctx) {
                                    return ctx.count + 1;
                                } }) },
                        '': {
                            target: 'stop',
                            cond: function (ctx) {
                                return ctx.count === 2;
                            }
                        }
                    }
                },
                stop: {
                    type: 'final'
                }
            }
        }, {
            services: {
                child: childMachine
            }
        });
        var count;
        interpret(someParentMachine).onTransition(function (state) {
            count = state.context.count;
        }).onDone(function () {
            // 1. The 'parent' machine will enter 'start' state
            // 2. The 'child' service will be run with ID 'someService'
            // 3. The 'child' machine will enter 'init' state
            // 4. The 'onEntry' action will be executed, which sends 'INC' to 'parent' machine twice
            // 5. The context will be updated to increment count to 2
            assert.equal(count, 2);
            done();
        }).start();
    });
    it('should forward events to services if autoForward: true', function () {
        var childMachine = Machine({
            id: 'child',
            initial: 'init',
            states: {
                init: {
                    on: {
                        FORWARD_DEC: {
                            actions: [sendParent('DEC'), sendParent('DEC'), sendParent('DEC')]
                        }
                    }
                }
            }
        });
        var someParentMachine = Machine({
            id: 'parent',
            context: { count: 0 },
            initial: 'start',
            states: {
                start: {
                    invoke: {
                        src: 'child',
                        id: 'someService',
                        autoForward: true
                    },
                    on: {
                        DEC: { actions: assign({ count: function (ctx) {
                                    return ctx.count - 1;
                                } }) },
                        FORWARD_DEC: undefined,
                        '': {
                            target: 'stop',
                            cond: function (ctx) {
                                return ctx.count === -3;
                            }
                        }
                    }
                },
                stop: {
                    type: 'final'
                }
            }
        }, {
            services: {
                child: childMachine
            }
        });
        var state;
        var service = interpret(someParentMachine).onTransition(function (s) {
            state = s;
        }).onDone(function () {
            // 1. The 'parent' machine will not do anything (inert transition)
            // 2. The 'FORWARD_DEC' event will be forwarded to the 'child' machine (autoForward: true)
            // 3. On the 'child' machine, the 'FORWARD_DEC' event sends the 'DEC' action to the 'parent' thrice
            // 4. The context of the 'parent' machine will be updated from 2 to -1
            assert.deepEqual(state.context, { count: -3 });
        }).start();
        service.send('FORWARD_DEC');
    });
    it('should start services (explicit machine, invoke = config)', function (done) {
        interpret(fetcherMachine).onDone(function () {
            done();
        }).start().send('GO_TO_WAITING');
    });
    it('should start services (explicit machine, invoke = machine)', function (done) {
        interpret(fetcherMachine).onDone(function (_) {
            done();
        }).start().send('GO_TO_WAITING_MACHINE');
    });
    it('should start services (machine as invoke config)', function (done) {
        var machineInvokeMachine = Machine({
            id: 'machine-invoke',
            initial: 'pending',
            states: {
                pending: {
                    invoke: Machine({
                        id: 'child',
                        initial: 'sending',
                        states: {
                            sending: {
                                entry: sendParent({ type: 'SUCCESS', data: 42 })
                            }
                        }
                    }),
                    on: {
                        SUCCESS: {
                            target: 'success',
                            cond: function (_, e) {
                                return e.data === 42;
                            }
                        }
                    }
                },
                success: {
                    type: 'final'
                }
            }
        });
        interpret(machineInvokeMachine).onDone(function () {
            return done();
        }).start();
    });
    it('should use the service overwritten by withConfig', function (done) {
        var childMachine = Machine({
            id: 'child',
            initial: 'init',
            states: {
                init: {}
            }
        });
        var someParentMachine = Machine({
            id: 'parent',
            context: { count: 0 },
            initial: 'start',
            states: {
                start: {
                    invoke: {
                        src: 'child',
                        id: 'someService',
                        autoForward: true
                    },
                    on: {
                        STOP: 'stop'
                    }
                },
                stop: {
                    type: 'final'
                }
            }
        }, {
            services: {
                child: childMachine
            }
        });
        interpret(someParentMachine.withConfig({
            services: {
                child: Machine({
                    id: 'child',
                    initial: 'init',
                    states: {
                        init: {
                            onEntry: [sendParent('STOP')]
                        }
                    }
                })
            }
        })).onDone(function () {
            done();
        }).start();
    });
    it('should not start services only once when using withContext', function () {
        var startCount = 0;
        var startMachine = Machine({
            id: 'start',
            initial: 'active',
            context: { foo: true },
            states: {
                active: {
                    invoke: {
                        src: function () {
                            return function () {
                                startCount++;
                            };
                        }
                    }
                }
            }
        });
        var startService = interpret(startMachine.withContext({ foo: false }));
        startService.start();
        assert.equal(startCount, 1);
    });
    describe('parent to child', function () {
        var subMachine = Machine({
            id: 'child',
            initial: 'one',
            states: {
                one: {
                    on: { NEXT: 'two' }
                },
                two: {
                    onEntry: sendParent('NEXT')
                }
            }
        });
        it('should communicate with the child machine (invoke on machine)', function (done) {
            var mainMachine = Machine({
                id: 'parent',
                initial: 'one',
                invoke: {
                    id: 'foo-child',
                    src: subMachine
                },
                states: {
                    one: {
                        onEntry: send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpret(mainMachine).onDone(function () {
                done();
            }).start();
        });
        it('should communicate with the child machine (invoke on created machine)', function (done) {
            var mainMachine = Machine({
                id: 'parent',
                initial: 'one',
                context: {
                    machine: subMachine
                },
                invoke: {
                    id: 'foo-child',
                    src: function (ctx) {
                        return ctx.machine;
                    }
                },
                states: {
                    one: {
                        onEntry: send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpret(mainMachine).onDone(function () {
                done();
            }).start();
        });
        it('should communicate with the child machine (invoke on state)', function (done) {
            var mainMachine = Machine({
                id: 'parent',
                initial: 'one',
                states: {
                    one: {
                        invoke: {
                            id: 'foo-child',
                            src: subMachine
                        },
                        onEntry: send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpret(mainMachine).onDone(function () {
                done();
            }).start();
        });
        it('should transition correctly if child invocation causes it to directly go to final state', function (done) {
            var doneSubMachine = Machine({
                id: 'child',
                initial: 'one',
                states: {
                    one: {
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            var mainMachine = Machine({
                id: 'parent',
                initial: 'one',
                states: {
                    one: {
                        invoke: {
                            id: 'foo-child',
                            src: doneSubMachine,
                            onDone: 'two'
                        },
                        onEntry: send('NEXT', { to: 'foo-child' })
                    },
                    two: {
                        on: { NEXT: 'three' }
                    },
                    three: {
                        type: 'final'
                    }
                }
            });
            var expectedStateValue = 'two';
            var currentState;
            interpret(mainMachine).onTransition(function (current) {
                return currentState = current;
            }).start();
            setTimeout(function () {
                assert.equal(currentState.value, expectedStateValue);
                done();
            }, 30);
        });
        it('should work with invocations defined in orthogonal state nodes', function (done) {
            var pongMachine = Machine({
                id: 'pong',
                initial: 'active',
                states: {
                    active: {
                        type: 'final',
                        data: { secret: 'pingpong' }
                    }
                }
            });
            var pingMachine = Machine({
                id: 'ping',
                type: 'parallel',
                states: {
                    one: {
                        initial: 'active',
                        states: {
                            active: {
                                invoke: {
                                    id: 'pong',
                                    src: pongMachine,
                                    onDone: {
                                        target: 'success',
                                        cond: function (_, e) {
                                            return e.data.secret === 'pingpong';
                                        }
                                    }
                                }
                            },
                            success: {
                                type: 'final'
                            }
                        }
                    }
                }
            });
            interpret(pingMachine).onDone(function () {
                done();
            }).start();
        });
    });
    var promiseTypes = [{
        type: 'Promise',
        createPromise: function (executor) {
            return new Promise(executor);
        }
    }, {
        type: 'PromiseLike',
        createPromise: function (executor) {
            // Simulate a Promise/A+ thenable / polyfilled Promise.
            function createThenable(promise) {
                return {
                    then: function (onfulfilled, onrejected) {
                        return createThenable(promise.then(onfulfilled, onrejected));
                    }
                };
            }
            return createThenable(new Promise(executor));
        }
    }];
    promiseTypes.forEach(function (_a) {
        var type = _a.type,
            createPromise = _a.createPromise;
        describe("with promises (" + type + ")", function () {
            var invokePromiseMachine = Machine({
                id: 'invokePromise',
                initial: 'pending',
                context: {
                    id: 42,
                    succeed: true
                },
                states: {
                    pending: {
                        invoke: {
                            src: function (ctx) {
                                return createPromise(function (resolve) {
                                    if (ctx.succeed) {
                                        resolve(ctx.id);
                                    } else {
                                        throw new Error("failed on purpose for: " + ctx.id);
                                    }
                                });
                            },
                            onDone: {
                                target: 'success',
                                cond: function (ctx, e) {
                                    return e.data === ctx.id;
                                }
                            },
                            onError: 'failure'
                        }
                    },
                    success: {
                        type: 'final'
                    },
                    failure: {
                        type: 'final'
                    }
                }
            });
            it('should be invoked with a promise factory and resolve through onDone', function (done) {
                interpret(invokePromiseMachine).onDone(function () {
                    return done();
                }).start();
            });
            it('should be invoked with a promise factory and reject with ErrorExecution', function (done) {
                interpret(invokePromiseMachine.withContext({ id: 31, succeed: false })).onDone(function () {
                    return done();
                }).start();
            });
            it('should be invoked with a promise factory and ignore unhandled onError target', function (done) {
                var promiseMachine = Machine({
                    id: 'invokePromise',
                    initial: 'pending',
                    states: {
                        pending: {
                            invoke: {
                                src: function () {
                                    return createPromise(function () {
                                        throw new Error('test');
                                    });
                                },
                                onDone: 'success'
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    return assert.fail('should not be called');
                }).onStop(function () {
                    return assert.fail('should not be called');
                }).start();
                // assumes that error was ignored before the timeout is processed
                setTimeout(function () {
                    return done();
                }, 10);
            });
            it('should be invoked with a promise factory and stop on unhandled onError target when on strict mode', function (done) {
                var promiseMachine = Machine({
                    id: 'invokePromise',
                    initial: 'pending',
                    strict: true,
                    states: {
                        pending: {
                            invoke: {
                                src: function () {
                                    return createPromise(function () {
                                        throw new Error('test');
                                    });
                                },
                                onDone: 'success'
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    return assert.fail('should not be called');
                }).onStop(function () {
                    return done();
                }).start();
            });
            it('should be invoked with a promise factory and resolve through onDone for compound state nodes', function (done) {
                var promiseMachine = Machine({
                    id: 'promise',
                    initial: 'parent',
                    states: {
                        parent: {
                            initial: 'pending',
                            states: {
                                pending: {
                                    invoke: {
                                        src: function () {
                                            return createPromise(function (resolve) {
                                                return resolve();
                                            });
                                        },
                                        onDone: 'success'
                                    }
                                },
                                success: {
                                    type: 'final'
                                }
                            },
                            onDone: 'success'
                        },
                        success: {
                            type: 'final'
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    return done();
                }).start();
            });
            it('should be invoked with a promise service and resolve through onDone for compound state nodes', function (done) {
                var promiseMachine = Machine({
                    id: 'promise',
                    initial: 'parent',
                    states: {
                        parent: {
                            initial: 'pending',
                            states: {
                                pending: {
                                    invoke: {
                                        src: 'somePromise',
                                        onDone: 'success'
                                    }
                                },
                                success: {
                                    type: 'final'
                                }
                            },
                            onDone: 'success'
                        },
                        success: {
                            type: 'final'
                        }
                    }
                }, {
                    services: {
                        somePromise: function () {
                            return createPromise(function (resolve) {
                                return resolve();
                            });
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    return done();
                }).start();
            });
            it('should assign the resolved data when invoked with a promise factory', function (done) {
                var promiseMachine = Machine({
                    id: 'promise',
                    context: { count: 0 },
                    initial: 'pending',
                    states: {
                        pending: {
                            invoke: {
                                src: function () {
                                    return createPromise(function (resolve) {
                                        return resolve({ count: 1 });
                                    });
                                },
                                onDone: {
                                    target: 'success',
                                    actions: assign({ count: function (_, e) {
                                            return e.data.count;
                                        } })
                                }
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                });
                var state;
                interpret(promiseMachine).onTransition(function (s) {
                    state = s;
                }).onDone(function () {
                    assert.equal(state.context.count, 1);
                    done();
                }).start();
            });
            it('should assign the resolved data when invoked with a promise service', function (done) {
                var promiseMachine = Machine({
                    id: 'promise',
                    context: { count: 0 },
                    initial: 'pending',
                    states: {
                        pending: {
                            invoke: {
                                src: 'somePromise',
                                onDone: {
                                    target: 'success',
                                    actions: assign({ count: function (_, e) {
                                            return e.data.count;
                                        } })
                                }
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                }, {
                    services: {
                        somePromise: function () {
                            return createPromise(function (resolve) {
                                return resolve({ count: 1 });
                            });
                        }
                    }
                });
                var state;
                interpret(promiseMachine).onTransition(function (s) {
                    state = s;
                }).onDone(function () {
                    assert.equal(state.context.count, 1);
                    done();
                }).start();
            });
            it('should provide the resolved data when invoked with a promise factory', function (done) {
                var count = 0;
                var promiseMachine = Machine({
                    id: 'promise',
                    context: { count: 0 },
                    initial: 'pending',
                    states: {
                        pending: {
                            invoke: {
                                src: function () {
                                    return createPromise(function (resolve) {
                                        return resolve({ count: 1 });
                                    });
                                },
                                onDone: {
                                    target: 'success',
                                    actions: function (_, e) {
                                        count = e.data.count;
                                    }
                                }
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    assert.equal(count, 1);
                    done();
                }).start();
            });
            it('should provide the resolved data when invoked with a promise service', function (done) {
                var count = 0;
                var promiseMachine = Machine({
                    id: 'promise',
                    initial: 'pending',
                    states: {
                        pending: {
                            invoke: {
                                src: 'somePromise',
                                onDone: {
                                    target: 'success',
                                    actions: function (_, e) {
                                        count = e.data.count;
                                    }
                                }
                            }
                        },
                        success: {
                            type: 'final'
                        }
                    }
                }, {
                    services: {
                        somePromise: function () {
                            return createPromise(function (resolve) {
                                return resolve({ count: 1 });
                            });
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    assert.equal(count, 1);
                    done();
                }).start();
            });
            it('should be able to specify a Promise as a service', function (done) {
                var promiseMachine = Machine({
                    id: 'promise',
                    initial: 'pending',
                    context: { foo: true },
                    states: {
                        pending: {
                            on: { BEGIN: 'first' }
                        },
                        first: {
                            invoke: {
                                src: 'somePromise',
                                onDone: 'last'
                            }
                        },
                        last: {
                            type: 'final'
                        }
                    }
                }, {
                    services: {
                        somePromise: function (ctx, e) {
                            return createPromise(function (resolve, reject) {
                                ctx.foo && e.payload ? resolve() : reject();
                            });
                        }
                    }
                });
                interpret(promiseMachine).onDone(function () {
                    return done();
                }).start().send({ type: 'BEGIN', payload: true });
            });
        });
    });
    describe('with callbacks', function () {
        it('should be able to specify a callback as a service', function (done) {
            var callbackMachine = Machine({
                id: 'callback',
                initial: 'pending',
                context: { foo: true },
                states: {
                    pending: {
                        on: { BEGIN: 'first' }
                    },
                    first: {
                        invoke: {
                            src: 'someCallback'
                        },
                        on: {
                            CALLBACK: {
                                target: 'last',
                                cond: function (_, e) {
                                    return e.data === 42;
                                }
                            }
                        }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    someCallback: function (ctx, e) {
                        return function (cb) {
                            if (ctx.foo && e.payload) {
                                cb({ type: 'CALLBACK', data: 40 });
                                cb({ type: 'CALLBACK', data: 41 });
                                cb({ type: 'CALLBACK', data: 42 });
                            }
                        };
                    }
                }
            });
            interpret(callbackMachine).onDone(function () {
                return done();
            }).start().send({ type: 'BEGIN', payload: true });
        });
        it('should transition correctly if callback function sends an event', function () {
            var callbackMachine = Machine({
                id: 'callback',
                initial: 'pending',
                context: { foo: true },
                states: {
                    pending: {
                        on: { BEGIN: 'first' }
                    },
                    first: {
                        invoke: {
                            src: 'someCallback'
                        },
                        on: { CALLBACK: 'intermediate' }
                    },
                    intermediate: {
                        on: { NEXT: 'last' }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    someCallback: function () {
                        return function (cb) {
                            cb('CALLBACK');
                        };
                    }
                }
            });
            var expectedStateValues = ['pending', 'first', 'intermediate'];
            var stateValues = [];
            interpret(callbackMachine).onTransition(function (current) {
                return stateValues.push(current.value);
            }).start().send('BEGIN');
            for (var i = 0; i < expectedStateValues.length; i++) {
                assert.equal(stateValues[i], expectedStateValues[i]);
            }
        });
        it('should transition correctly if callback function invoked from start and sends an event', function () {
            var callbackMachine = Machine({
                id: 'callback',
                initial: 'idle',
                context: { foo: true },
                states: {
                    idle: {
                        invoke: {
                            src: 'someCallback'
                        },
                        on: { CALLBACK: 'intermediate' }
                    },
                    intermediate: {
                        on: { NEXT: 'last' }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    someCallback: function () {
                        return function (cb) {
                            cb('CALLBACK');
                        };
                    }
                }
            });
            var expectedStateValues = ['idle', 'intermediate'];
            var stateValues = [];
            interpret(callbackMachine).onTransition(function (current) {
                return stateValues.push(current.value);
            }).start().send('BEGIN');
            for (var i = 0; i < expectedStateValues.length; i++) {
                assert.equal(stateValues[i], expectedStateValues[i]);
            }
        });
        // tslint:disable-next-line:max-line-length
        it('should transition correctly if transient transition happens before current state invokes callback function and sends an event', function () {
            var callbackMachine = Machine({
                id: 'callback',
                initial: 'pending',
                context: { foo: true },
                states: {
                    pending: {
                        on: { BEGIN: 'first' }
                    },
                    first: {
                        on: { '': 'second' }
                    },
                    second: {
                        invoke: {
                            src: 'someCallback'
                        },
                        on: { CALLBACK: 'third' }
                    },
                    third: {
                        on: { NEXT: 'last' }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    someCallback: function () {
                        return function (cb) {
                            cb('CALLBACK');
                        };
                    }
                }
            });
            var expectedStateValues = ['pending', 'second', 'third'];
            var stateValues = [];
            interpret(callbackMachine).onTransition(function (current) {
                return stateValues.push(current.value);
            }).start().send('BEGIN');
            for (var i = 0; i < expectedStateValues.length; i++) {
                assert.equal(stateValues[i], expectedStateValues[i]);
            }
        });
        it('should treat a callback source as an event stream', function (done) {
            interpret(intervalMachine).onDone(function () {
                return done();
            }).start();
        });
        it('should dispose of the callback (if disposal function provided)', function (done) {
            var state;
            var service = interpret(intervalMachine).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                // if intervalService isn't disposed after skipping, 'INC' event will
                // keep being sent
                assert.equal(state.context.count, 0, 'should exit interval service before the first event is sent');
                done();
            }).start();
            // waits 50 milliseconds before going to final state.
            service.send('SKIP');
        });
        it('callback should be able to receive messages from parent', function (done) {
            var pingPongMachine = Machine({
                id: 'ping-pong',
                initial: 'active',
                states: {
                    active: {
                        invoke: {
                            id: 'child',
                            src: function () {
                                return function (next, onEvent) {
                                    onEvent(function (e) {
                                        if (e.type === 'PING') {
                                            next('PONG');
                                        }
                                    });
                                };
                            }
                        },
                        onEntry: send('PING', { to: 'child' }),
                        on: {
                            PONG: 'done'
                        }
                    },
                    done: {
                        type: 'final'
                    }
                }
            });
            interpret(pingPongMachine).onDone(function () {
                return done();
            }).start();
        });
        it('should call onError upon error (sync)', function (done) {
            var errorMachine = Machine({
                id: 'error',
                initial: 'safe',
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    throw new Error('test');
                                };
                            },
                            onError: {
                                target: 'failed',
                                cond: function (_, e) {
                                    return e.data instanceof Error && e.data.message === 'test';
                                }
                            }
                        }
                    },
                    failed: {
                        type: 'final'
                    }
                }
            });
            interpret(errorMachine).onDone(function () {
                return done();
            }).start();
        });
        it('should transition correctly upon error (sync)', function () {
            var errorMachine = Machine({
                id: 'error',
                initial: 'safe',
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    throw new Error('test');
                                };
                            },
                            onError: 'failed'
                        }
                    },
                    failed: {
                        on: { RETRY: 'safe' }
                    }
                }
            });
            var expectedStateValue = 'failed';
            var currentState;
            interpret(errorMachine).onTransition(function (current) {
                return currentState = current;
            }).start();
            assert.equal(currentState.value, expectedStateValue);
        });
        it('should call onError upon error (async)', function (done) {
            var errorMachine = Machine({
                id: 'asyncError',
                initial: 'safe',
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    return [4 /*yield*/, true];
                                                case 1:
                                                    _a.sent();
                                                    throw new Error('test');
                                            }
                                        });
                                    });
                                };
                            },
                            onError: {
                                target: 'failed',
                                cond: function (_, e) {
                                    return e.data instanceof Error && e.data.message === 'test';
                                }
                            }
                        }
                    },
                    failed: {
                        type: 'final'
                    }
                }
            });
            interpret(errorMachine).onDone(function () {
                return done();
            }).start();
        });
        it('should call onDone when resolved (async)', function (done) {
            var state;
            var asyncWithDoneMachine = Machine({
                id: 'async',
                initial: 'fetch',
                context: { result: undefined },
                states: {
                    fetch: {
                        invoke: {
                            src: function () {
                                return function () {
                                    return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    return [4 /*yield*/, true];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/, 42];
                                            }
                                        });
                                    });
                                };
                            },
                            onDone: {
                                target: 'success',
                                actions: assign(function (_, _a) {
                                    var result = _a.data;
                                    return { result: result };
                                })
                            }
                        }
                    },
                    success: {
                        type: 'final'
                    }
                }
            });
            interpret(asyncWithDoneMachine).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                assert.equal(state.context.result, 42);
                done();
            }).start();
        });
        it('should call onError only on the state which has invoked failed service', function () {
            var errorHandlersCalled = 0;
            var errorMachine = Machine({
                initial: 'start',
                states: {
                    start: {
                        on: {
                            FETCH: 'fetch'
                        }
                    },
                    fetch: {
                        type: 'parallel',
                        states: {
                            first: {
                                invoke: {
                                    src: function () {
                                        return function () {
                                            throw new Error('test');
                                        };
                                    },
                                    onError: {
                                        target: 'failed',
                                        cond: function () {
                                            errorHandlersCalled++;
                                            return false;
                                        }
                                    }
                                }
                            },
                            second: {
                                invoke: {
                                    src: function () {
                                        return function () {
                                            // empty
                                        };
                                    },
                                    onError: {
                                        target: 'failed',
                                        cond: function () {
                                            errorHandlersCalled++;
                                            return false;
                                        }
                                    }
                                }
                            },
                            failed: {
                                type: 'final'
                            }
                        }
                    }
                }
            });
            interpret(errorMachine).start().send('FETCH');
            assert.equal(errorHandlersCalled, 1);
        });
        it('should be able to be stringified', function () {
            var waitingState = fetcherMachine.transition(fetcherMachine.initialState, 'GO_TO_WAITING');
            assert.doesNotThrow(function () {
                JSON.stringify(waitingState);
            });
            assert.isString(waitingState.actions[0].activity.src);
        });
        it('should throw error if unhandled (sync)', function () {
            var errorMachine = Machine({
                id: 'asyncError',
                initial: 'safe',
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    throw new Error('test');
                                };
                            }
                        }
                    },
                    failed: {
                        type: 'final'
                    }
                }
            });
            var service = interpret(errorMachine);
            assert.throws(function () {
                return service.start();
            }, 'test');
        });
        it('should stop machine if unhandled error and on strict mode (async)', function (done) {
            var errorMachine = Machine({
                id: 'asyncError',
                initial: 'safe',
                // if not in strict mode we have no way to know if there
                // was an error with processing rejected promise
                strict: true,
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    return [4 /*yield*/, true];
                                                case 1:
                                                    _a.sent();
                                                    throw new Error('test');
                                            }
                                        });
                                    });
                                };
                            }
                        }
                    },
                    failed: {
                        type: 'final'
                    }
                }
            });
            interpret(errorMachine).onStop(function () {
                return done();
            }).start();
        });
        it('should ignore error if unhandled error and not on strict mode (async)', function (done) {
            var errorMachine = Machine({
                id: 'asyncError',
                initial: 'safe',
                // if not in strict mode we have no way to know if there
                // was an error with processing rejected promise
                strict: false,
                states: {
                    safe: {
                        invoke: {
                            src: function () {
                                return function () {
                                    return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    return [4 /*yield*/, true];
                                                case 1:
                                                    _a.sent();
                                                    throw new Error('test');
                                            }
                                        });
                                    });
                                };
                            }
                        }
                    },
                    failed: {
                        type: 'final'
                    }
                }
            });
            interpret(errorMachine).onDone(function () {
                return assert.fail('should not be called');
            }).onStop(function () {
                return assert.fail('should not be called');
            }).start();
            // assumes that error was ignored before the timeout is processed
            setTimeout(function () {
                return done();
            }, 20);
        });
        describe('sub invoke race condition', function () {
            var anotherChildMachine = Machine({
                id: 'child',
                initial: 'start',
                states: {
                    start: {
                        on: { STOP: 'end' }
                    },
                    end: {
                        type: 'final'
                    }
                }
            });
            var anotherParentMachine = Machine({
                id: 'parent',
                initial: 'begin',
                states: {
                    begin: {
                        invoke: {
                            src: anotherChildMachine,
                            id: 'invoked.child',
                            onDone: 'completed'
                        },
                        on: {
                            STOPCHILD: {
                                actions: send('STOP', { to: 'invoked.child' })
                            }
                        }
                    },
                    completed: {
                        type: 'final'
                    }
                }
            });
            it('ends on the completed state', function (done) {
                var events = [];
                var state;
                var service = interpret(anotherParentMachine).onTransition(function (s) {
                    state = s;
                }).onEvent(function (e) {
                    events.push(e);
                }).onDone(function () {
                    assert.deepEqual(events.map(function (e) {
                        return e.type;
                    }), [actionTypes.init, 'STOPCHILD', doneInvoke('invoked.child').type]);
                    assert.equal(state.value, 'completed');
                    done();
                }).start();
                service.send('STOPCHILD');
            });
        });
    });
    describe('with observables', function () {
        var infinite$ = interval(10);
        it('should work with an infinite observable', function (done) {
            var obsMachine = Machine({
                id: 'obs',
                initial: 'counting',
                context: { count: undefined },
                states: {
                    counting: {
                        invoke: {
                            src: function () {
                                return infinite$.pipe(map(function (value) {
                                    return { type: 'COUNT', value: value };
                                }));
                            }
                        },
                        on: {
                            '': {
                                target: 'counted',
                                cond: function (ctx) {
                                    return ctx.count === 5;
                                }
                            },
                            COUNT: { actions: assign({ count: function (_, e) {
                                        return e.value;
                                    } }) }
                        }
                    },
                    counted: {
                        type: 'final'
                    }
                }
            });
            interpret(obsMachine).onDone(function () {
                done();
            }).start();
        });
        it('should work with a finite observable', function (done) {
            var obsMachine = Machine({
                id: 'obs',
                initial: 'counting',
                context: { count: undefined },
                states: {
                    counting: {
                        invoke: {
                            src: function () {
                                return infinite$.pipe(take(5), map(function (value) {
                                    return { type: 'COUNT', value: value };
                                }));
                            },
                            onDone: {
                                target: 'counted',
                                cond: function (ctx) {
                                    return ctx.count === 4;
                                }
                            }
                        },
                        on: {
                            COUNT: { actions: assign({ count: function (_, e) {
                                        return e.value;
                                    } }) }
                        }
                    },
                    counted: {
                        type: 'final'
                    }
                }
            });
            interpret(obsMachine).onDone(function () {
                done();
            }).start();
        });
        it('should receive an emitted error', function (done) {
            var obsMachine = Machine({
                id: 'obs',
                initial: 'counting',
                context: { count: undefined },
                states: {
                    counting: {
                        invoke: {
                            src: function () {
                                return infinite$.pipe(map(function (value) {
                                    if (value === 5) {
                                        throw new Error('some error');
                                    }
                                    return { type: 'COUNT', value: value };
                                }));
                            },
                            onError: {
                                target: 'success',
                                cond: function (ctx, e) {
                                    assert.equal(e.data.message, 'some error');
                                    return ctx.count === 4 && e.data.message === 'some error';
                                }
                            }
                        },
                        on: {
                            COUNT: { actions: assign({ count: function (_, e) {
                                        return e.value;
                                    } }) }
                        }
                    },
                    success: {
                        type: 'final'
                    }
                }
            });
            interpret(obsMachine).onDone(function () {
                done();
            }).start();
        });
    });
    describe('nested invoked machine', function () {
        var pongMachine = Machine({
            id: 'pong',
            initial: 'active',
            states: {
                active: {
                    on: {
                        PING: {
                            // Sends 'PONG' event to parent machine
                            actions: sendParent('PONG')
                        }
                    }
                }
            }
        });
        // Parent machine
        var pingMachine = Machine({
            id: 'ping',
            initial: 'innerMachine',
            states: {
                innerMachine: {
                    initial: 'active',
                    states: {
                        active: {
                            invoke: {
                                id: 'pong',
                                src: pongMachine
                            },
                            // Sends 'PING' event to child machine with ID 'pong'
                            onEntry: send('PING', { to: 'pong' }),
                            on: {
                                PONG: 'innerSuccess'
                            }
                        },
                        innerSuccess: {
                            type: 'final'
                        }
                    },
                    onDone: 'success'
                },
                success: { type: 'final' }
            }
        });
        it('should create invocations from machines in nested states', function (done) {
            interpret(pingMachine).onDone(function () {
                return done();
            }).start();
        });
    });
    describe('multiple simultaneous services', function () {
        // @ts-ignore
        var multiple = Machine({
            id: 'machine',
            initial: 'one',
            context: {},
            on: {
                ONE: {
                    actions: assign({
                        one: 'one'
                    })
                },
                TWO: {
                    actions: assign({
                        two: 'two'
                    }),
                    target: '.three'
                }
            },
            states: {
                one: {
                    initial: 'two',
                    states: {
                        two: {
                            invoke: [{
                                id: 'child',
                                src: function () {
                                    return function (cb) {
                                        return cb('ONE');
                                    };
                                }
                            }, {
                                id: 'child2',
                                src: function () {
                                    return function (cb) {
                                        return cb('TWO');
                                    };
                                }
                            }]
                        }
                    }
                },
                three: {
                    type: 'final'
                }
            }
        });
        it('should start all services at once', function (done) {
            var state;
            var service = interpret(multiple).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                assert.deepEqual(state.context, { one: 'one', two: 'two' });
                done();
            });
            service.start();
        });
        var parallel = Machine({
            id: 'machine',
            initial: 'one',
            context: {},
            on: {
                ONE: {
                    actions: assign({
                        one: 'one'
                    })
                },
                TWO: {
                    actions: assign({
                        two: 'two'
                    }),
                    target: '.three'
                }
            },
            states: {
                one: {
                    initial: 'two',
                    states: {
                        two: {
                            type: 'parallel',
                            states: {
                                a: {
                                    invoke: {
                                        id: 'child',
                                        src: function () {
                                            return function (cb) {
                                                return cb('ONE');
                                            };
                                        }
                                    }
                                },
                                b: {
                                    invoke: {
                                        id: 'child2',
                                        src: function () {
                                            return function (cb) {
                                                return cb('TWO');
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                three: {
                    type: 'final'
                }
            }
        });
        it('should run services in parallel', function (done) {
            var state;
            var service = interpret(parallel).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                assert.deepEqual(state.context, { one: 'one', two: 'two' });
                done();
            });
            service.start();
        });
        it('should not invoke a service if transient', function (done) {
            // Since an invocation will be canceled when the state machine leaves the
            // invoking state, it does not make sense to start an invocation in a state
            // that will be exited immediately
            var serviceCalled = false;
            var transientMachine = Machine({
                id: 'transient',
                initial: 'active',
                states: {
                    active: {
                        invoke: {
                            id: 'doNotInvoke',
                            src: function () {
                                return function () {
                                    return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            serviceCalled = true;
                                            return [2 /*return*/];
                                        });
                                    });
                                };
                            }
                        },
                        on: {
                            '': 'inactive'
                        }
                    },
                    inactive: {
                        after: { 10: 'complete' }
                    },
                    complete: {
                        type: 'final'
                    }
                }
            });
            var service = interpret(transientMachine);
            service.onDone(function () {
                assert.isFalse(serviceCalled, 'service should not be called');
                done();
            }).start();
        });
    });
});
//# sourceMappingURL=invoke.test.js.map