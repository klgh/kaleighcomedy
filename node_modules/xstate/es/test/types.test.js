import { assert } from 'chai';
import { Machine, assign } from '../src/index';
function noop(_x) {
    return;
}
describe('StateSchema', function () {
    var lightMachine = Machine({
        key: 'light',
        initial: 'green',
        meta: { interval: 1000 },
        context: { elapsed: 0 },
        states: {
            green: {
                meta: { name: 'greenLight' },
                on: {
                    TIMER: 'yellow',
                    POWER_OUTAGE: 'red'
                }
            },
            yellow: {
                on: {
                    TIMER: 'red',
                    POWER_OUTAGE: 'red'
                }
            },
            red: {
                on: {
                    TIMER: 'green',
                    POWER_OUTAGE: 'red'
                },
                initial: 'walk',
                states: {
                    walk: {
                        on: {
                            PED_COUNTDOWN: 'wait'
                        }
                    },
                    wait: {
                        on: {
                            PED_COUNTDOWN: {
                                target: 'stop',
                                cond: function (ctx, e) {
                                    return e.duration === 0 && ctx.elapsed > 0;
                                }
                            }
                        }
                    },
                    stop: {
                        on: {
                            '': { target: 'green' }
                        }
                    }
                }
            }
        }
    });
    noop(lightMachine);
    it('should work with a StateSchema defined', function () {
        assert.ok(true, 'Tests will not compile if types are wrong');
    });
});
describe('Parallel StateSchema', function () {
    var parallelMachine = Machine({
        type: 'parallel',
        states: {
            foo: {},
            bar: {},
            baz: {
                initial: 'one',
                states: {
                    one: { on: { E: 'two' } },
                    two: {}
                }
            }
        }
    });
    noop(parallelMachine);
    it('should work with a parallel StateSchema defined', function () {
        assert.ok(true, 'Tests will not compile if types are wrong');
    });
});
describe('Nested parallel stateSchema', function () {
    var nestedParallelMachine = Machine({
        initial: 'foo',
        states: {
            foo: {},
            bar: {},
            baz: {
                type: 'parallel',
                initial: 'blockUpdates',
                states: {
                    blockUpdates: { type: 'final' },
                    activeParallelNode: {
                        on: {
                            'UPDATE.CONTEXT': {
                                actions: [assign({
                                    lastDate: new Date()
                                })]
                            }
                        }
                    }
                }
            }
        }
    });
    noop(nestedParallelMachine);
    it('should work with a parallel StateSchema defined', function () {
        assert.ok(true, 'Tests will not compile if types are wrong');
    });
});
//# sourceMappingURL=types.test.js.map