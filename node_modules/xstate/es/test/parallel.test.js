import { assert } from 'chai';
import { raise, assign } from '../src/actions';
import { Machine } from '../src/Machine';
import { testMultiTransition } from './utils';
var composerMachine = /*#__PURE__*/Machine({
    strict: true,
    initial: 'ReadOnly',
    states: {
        ReadOnly: {
            id: 'ReadOnly',
            initial: 'StructureEdit',
            onEntry: ['selectNone'],
            states: {
                StructureEdit: {
                    id: 'StructureEditRO',
                    type: 'parallel',
                    on: {
                        switchToProjectManagement: [{
                            target: 'ProjectManagement'
                        }]
                    },
                    states: {
                        SelectionStatus: {
                            initial: 'SelectedNone',
                            on: {
                                singleClickActivity: [{
                                    target: '.SelectedActivity',
                                    actions: ['selectActivity']
                                }],
                                singleClickLink: [{
                                    target: '.SelectedLink',
                                    actions: ['selectLink']
                                }]
                            },
                            states: {
                                SelectedNone: {
                                    onEntry: ['redraw']
                                },
                                SelectedActivity: {
                                    onEntry: ['redraw'],
                                    on: {
                                        singleClickCanvas: [{
                                            target: 'SelectedNone',
                                            actions: ['selectNone']
                                        }]
                                    }
                                },
                                SelectedLink: {
                                    onEntry: ['redraw'],
                                    on: {
                                        singleClickCanvas: [{
                                            target: 'SelectedNone',
                                            actions: ['selectNone']
                                        }]
                                    }
                                }
                            }
                        },
                        ClipboardStatus: {
                            initial: 'Empty',
                            states: {
                                Empty: {
                                    onEntry: ['emptyClipboard'],
                                    on: {
                                        cutInClipboardSuccess: [{
                                            target: 'FilledByCut'
                                        }],
                                        copyInClipboardSuccess: [{
                                            target: 'FilledByCopy'
                                        }]
                                    }
                                },
                                FilledByCopy: {
                                    on: {
                                        cutInClipboardSuccess: [{
                                            target: 'FilledByCut'
                                        }],
                                        copyInClipboardSuccess: [{
                                            target: 'FilledByCopy'
                                        }],
                                        pasteFromClipboardSuccess: [{
                                            target: 'FilledByCopy'
                                        }]
                                    }
                                },
                                FilledByCut: {
                                    on: {
                                        cutInClipboardSuccess: [{
                                            target: 'FilledByCut'
                                        }],
                                        copyInClipboardSuccess: [{
                                            target: 'FilledByCopy'
                                        }],
                                        pasteFromClipboardSuccess: [{
                                            target: 'Empty'
                                        }]
                                    }
                                }
                            }
                        }
                    }
                },
                ProjectManagement: {
                    id: 'ProjectManagementRO',
                    type: 'parallel',
                    on: {
                        switchToStructureEdit: [{
                            target: 'StructureEdit'
                        }]
                    },
                    states: {
                        SelectionStatus: {
                            initial: 'SelectedNone',
                            on: {
                                singleClickActivity: [{
                                    target: '.SelectedActivity',
                                    actions: ['selectActivity']
                                }],
                                singleClickLink: [{
                                    target: '.SelectedLink',
                                    actions: ['selectLink']
                                }]
                            },
                            states: {
                                SelectedNone: {
                                    onEntry: ['redraw']
                                },
                                SelectedActivity: {
                                    onEntry: ['redraw'],
                                    on: {
                                        singleClickCanvas: [{
                                            target: 'SelectedNone',
                                            actions: ['selectNone']
                                        }]
                                    }
                                },
                                SelectedLink: {
                                    onEntry: ['redraw'],
                                    on: {
                                        singleClickCanvas: [{
                                            target: 'SelectedNone',
                                            actions: ['selectNone']
                                        }]
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
});
var wakMachine = /*#__PURE__*/Machine({
    id: 'wakMachine',
    type: 'parallel',
    strict: true,
    states: {
        wak1: {
            initial: 'wak1sonA',
            states: {
                wak1sonA: {
                    onEntry: 'wak1sonAenter',
                    onExit: 'wak1sonAexit'
                },
                wak1sonB: {
                    onEntry: 'wak1sonBenter',
                    onExit: 'wak1sonBexit'
                }
            },
            on: {
                WAK1: '.wak1sonB'
            },
            onEntry: 'wak1enter',
            onExit: 'wak1exit'
        },
        wak2: {
            initial: 'wak2sonA',
            states: {
                wak2sonA: {
                    onEntry: 'wak2sonAenter',
                    onExit: 'wak2sonAexit'
                },
                wak2sonB: {
                    onEntry: 'wak2sonBenter',
                    onExit: 'wak2sonBexit'
                }
            },
            on: {
                WAK2: '.wak2sonB'
            },
            onEntry: 'wak2enter',
            onExit: 'wak2exit'
        }
    }
});
var wordMachine = /*#__PURE__*/Machine({
    id: 'word',
    type: 'parallel',
    states: {
        bold: {
            initial: 'off',
            states: {
                on: {
                    on: { TOGGLE_BOLD: 'off' }
                },
                off: {
                    on: { TOGGLE_BOLD: 'on' }
                }
            }
        },
        underline: {
            initial: 'off',
            states: {
                on: {
                    on: { TOGGLE_UNDERLINE: 'off' }
                },
                off: {
                    on: { TOGGLE_UNDERLINE: 'on' }
                }
            }
        },
        italics: {
            initial: 'off',
            states: {
                on: {
                    on: { TOGGLE_ITALICS: 'off' }
                },
                off: {
                    on: { TOGGLE_ITALICS: 'on' }
                }
            }
        },
        list: {
            initial: 'none',
            states: {
                none: {
                    on: { BULLETS: 'bullets', NUMBERS: 'numbers' }
                },
                bullets: {
                    on: { NONE: 'none', NUMBERS: 'numbers' }
                },
                numbers: {
                    on: { BULLETS: 'bullets', NONE: 'none' }
                }
            }
        }
    },
    on: {
        RESET: '#word' // TODO: this should be 'word' or [{ internal: false }]
    }
});
var flatParallelMachine = /*#__PURE__*/Machine({
    type: 'parallel',
    states: {
        foo: {},
        bar: {},
        baz: {
            initial: 'one',
            states: {
                one: { on: { E: 'two' } },
                two: {}
            }
        }
    }
});
var raisingParallelMachine = /*#__PURE__*/Machine({
    strict: true,
    type: 'parallel',
    states: {
        OUTER1: {
            initial: 'C',
            states: {
                A: {
                    onEntry: [/*#__PURE__*/raise('TURN_OFF')],
                    on: {
                        EVENT_OUTER1_B: 'B',
                        EVENT_OUTER1_C: 'C'
                    }
                },
                B: {
                    onEntry: [/*#__PURE__*/raise('TURN_ON')],
                    on: {
                        EVENT_OUTER1_A: 'A',
                        EVENT_OUTER1_C: 'C'
                    }
                },
                C: {
                    onEntry: [/*#__PURE__*/raise('CLEAR')],
                    on: {
                        EVENT_OUTER1_A: 'A',
                        EVENT_OUTER1_B: 'B'
                    }
                }
            }
        },
        OUTER2: {
            type: 'parallel',
            states: {
                INNER1: {
                    initial: 'ON',
                    states: {
                        OFF: {
                            on: {
                                TURN_ON: 'ON'
                            }
                        },
                        ON: {
                            on: {
                                CLEAR: 'OFF'
                            }
                        }
                    }
                },
                INNER2: {
                    initial: 'OFF',
                    states: {
                        OFF: {
                            on: {
                                TURN_ON: 'ON'
                            }
                        },
                        ON: {
                            on: {
                                TURN_OFF: 'OFF'
                            }
                        }
                    }
                }
            }
        }
    }
});
var nestedParallelState = /*#__PURE__*/Machine({
    type: 'parallel',
    states: {
        OUTER1: {
            initial: 'STATE_OFF',
            states: {
                STATE_OFF: {
                    on: {
                        EVENT_COMPLEX: 'STATE_ON',
                        EVENT_SIMPLE: 'STATE_ON'
                    }
                },
                STATE_ON: {
                    type: 'parallel',
                    states: {
                        STATE_NTJ0: {
                            initial: 'STATE_IDLE_0',
                            states: {
                                STATE_IDLE_0: {
                                    on: {
                                        EVENT_STATE_NTJ0_WORK: 'STATE_WORKING_0'
                                    }
                                },
                                STATE_WORKING_0: {
                                    on: {
                                        EVENT_STATE_NTJ0_IDLE: 'STATE_IDLE_0'
                                    }
                                }
                            }
                        },
                        STATE_NTJ1: {
                            initial: 'STATE_IDLE_1',
                            states: {
                                STATE_IDLE_1: {
                                    on: {
                                        EVENT_STATE_NTJ1_WORK: 'STATE_WORKING_1'
                                    }
                                },
                                STATE_WORKING_1: {
                                    on: {
                                        EVENT_STATE_NTJ1_IDLE: 'STATE_IDLE_1'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        OUTER2: {
            initial: 'STATE_OFF',
            states: {
                STATE_OFF: {
                    on: {
                        EVENT_COMPLEX: 'STATE_ON_COMPLEX',
                        EVENT_SIMPLE: 'STATE_ON_SIMPLE'
                    }
                },
                STATE_ON_SIMPLE: {},
                STATE_ON_COMPLEX: {
                    type: 'parallel',
                    states: {
                        STATE_INNER1: {
                            initial: 'STATE_OFF',
                            states: {
                                STATE_OFF: {},
                                STATE_ON: {}
                            }
                        },
                        STATE_INNER2: {
                            initial: 'STATE_OFF',
                            states: {
                                STATE_OFF: {},
                                STATE_ON: {}
                            }
                        }
                    }
                }
            }
        }
    }
});
var deepFlatParallelMachine = /*#__PURE__*/Machine({
    type: 'parallel',
    states: {
        X: {},
        V: {
            initial: 'A',
            on: {
                a: {
                    target: 'V.A'
                },
                b: {
                    target: 'V.B'
                },
                c: {
                    target: 'V.C'
                }
            },
            states: {
                A: {},
                B: {
                    initial: 'BB',
                    states: {
                        BB: {
                            type: 'parallel',
                            states: {
                                BBB_A: {},
                                BBB_B: {}
                            }
                        }
                    }
                },
                C: {}
            }
        }
    }
});
describe('parallel states', function () {
    var _a;
    it('should have initial parallel states', function () {
        var initialState = wordMachine.initialState;
        assert.deepEqual(initialState.value, {
            bold: 'off',
            italics: 'off',
            underline: 'off',
            list: 'none'
        });
    });
    var expected = (_a = {
        'bold.off': {
            TOGGLE_BOLD: {
                bold: 'on',
                italics: 'off',
                underline: 'off',
                list: 'none'
            }
        },
        'bold.on': {
            TOGGLE_BOLD: {
                bold: 'off',
                italics: 'off',
                underline: 'off',
                list: 'none'
            }
        }
    }, _a[JSON.stringify({
        bold: 'off',
        italics: 'off',
        underline: 'on',
        list: 'bullets'
    })] = {
        'TOGGLE_BOLD, TOGGLE_ITALICS': {
            bold: 'on',
            italics: 'on',
            underline: 'on',
            list: 'bullets'
        },
        RESET: {
            bold: 'off',
            italics: 'off',
            underline: 'off',
            list: 'none'
        }
    }, _a);
    Object.keys(expected).forEach(function (fromState) {
        Object.keys(expected[fromState]).forEach(function (eventTypes) {
            var toState = expected[fromState][eventTypes];
            it("should go from " + fromState + " to " + JSON.stringify(toState) + " on " + eventTypes, function () {
                var resultState = testMultiTransition(wordMachine, fromState, eventTypes);
                assert.deepEqual(resultState.value, toState);
            });
        });
    });
    it('should have all parallel states represented in the state value', function () {
        var nextState = wakMachine.transition(wakMachine.initialState, 'WAK1');
        assert.deepEqual(nextState.value, { wak1: 'wak1sonB', wak2: 'wak2sonA' });
    });
    it('should have all parallel states represented in the state value (2)', function () {
        var nextState = wakMachine.transition(wakMachine.initialState, 'WAK2');
        assert.deepEqual(nextState.value, { wak1: 'wak1sonA', wak2: 'wak2sonB' });
    });
    it('should work with regions without states', function () {
        assert.deepEqual(flatParallelMachine.initialState.value, {
            foo: {},
            bar: {},
            baz: 'one'
        });
    });
    it('should work with regions without states', function () {
        var nextState = flatParallelMachine.transition(flatParallelMachine.initialState, 'E');
        assert.deepEqual(nextState.value, {
            foo: {},
            bar: {},
            baz: 'two'
        });
    });
    it('should properly transition to relative substate', function () {
        var nextState = composerMachine.transition(composerMachine.initialState, 'singleClickActivity');
        assert.deepEqual(nextState.value, {
            ReadOnly: {
                StructureEdit: {
                    SelectionStatus: 'SelectedActivity',
                    ClipboardStatus: 'Empty'
                }
            }
        });
    });
    it('should properly transition according to onEntry events on an initial state', function () {
        assert.deepEqual(raisingParallelMachine.initialState.value, {
            OUTER1: 'C',
            OUTER2: {
                INNER1: 'OFF',
                INNER2: 'OFF'
            }
        });
    });
    it('should properly transition when raising events for a parallel state', function () {
        var nextState = raisingParallelMachine.transition(raisingParallelMachine.initialState, 'EVENT_OUTER1_B');
        assert.deepEqual(nextState.value, {
            OUTER1: 'B',
            OUTER2: {
                INNER1: 'ON',
                INNER2: 'ON'
            }
        });
    });
    xit('should handle simultaneous orthogonal transitions', function () {
        var simultaneousMachine = Machine({
            id: 'yamlEditor',
            type: 'parallel',
            context: {
                value: ''
            },
            states: {
                editing: {
                    on: {
                        CHANGE: {
                            actions: assign({
                                value: function (_, e) {
                                    return e.value;
                                }
                            })
                        }
                    }
                },
                status: {
                    initial: 'unsaved',
                    states: {
                        unsaved: {
                            on: {
                                SAVE: {
                                    target: 'saved',
                                    actions: 'save'
                                }
                            }
                        },
                        saved: {
                            on: {
                                CHANGE: 'unsaved'
                            }
                        }
                    }
                }
            }
        });
        var savedState = simultaneousMachine.transition(simultaneousMachine.initialState, 'SAVE');
        var unsavedState = simultaneousMachine.transition(savedState, {
            type: 'CHANGE',
            value: 'something'
        });
        assert.deepEqual(unsavedState.value, {});
    });
    describe('transitions with nested parallel states', function () {
        var initialState = nestedParallelState.initialState;
        var simpleNextState = nestedParallelState.transition(initialState, 'EVENT_SIMPLE');
        var complexNextState = nestedParallelState.transition(initialState, 'EVENT_COMPLEX');
        it('should properly transition when in a simple nested state', function () {
            var nextState = nestedParallelState.transition(simpleNextState, 'EVENT_STATE_NTJ0_WORK');
            assert.deepEqual(nextState.value, {
                OUTER1: {
                    STATE_ON: {
                        STATE_NTJ0: 'STATE_WORKING_0',
                        STATE_NTJ1: 'STATE_IDLE_1'
                    }
                },
                OUTER2: 'STATE_ON_SIMPLE'
            });
        });
        it('should properly transition when in a complex nested state', function () {
            var nextState = nestedParallelState.transition(complexNextState, 'EVENT_STATE_NTJ0_WORK');
            assert.deepEqual(nextState.value, {
                OUTER1: {
                    STATE_ON: {
                        STATE_NTJ0: 'STATE_WORKING_0',
                        STATE_NTJ1: 'STATE_IDLE_1'
                    }
                },
                OUTER2: {
                    STATE_ON_COMPLEX: {
                        STATE_INNER1: 'STATE_OFF',
                        STATE_INNER2: 'STATE_OFF'
                    }
                }
            });
        });
    });
    // https://github.com/davidkpiano/xstate/issues/191
    describe('nested flat parallel states', function () {
        var machine = Machine({
            initial: 'A',
            states: {
                A: {
                    on: {
                        'to-B': 'B'
                    }
                },
                B: {
                    type: 'parallel',
                    states: {
                        C: {},
                        D: {}
                    }
                }
            },
            on: {
                'to-A': 'A'
            }
        });
        it('should represent the flat nested parallel states in the state value', function () {
            var result = machine.transition(machine.initialState, 'to-B');
            assert.deepEqual(result.value, {
                B: {
                    C: {},
                    D: {}
                }
            });
        });
    });
    describe('deep flat parallel states', function () {
        it('should properly evaluate deep flat parallel states', function () {
            var state1 = deepFlatParallelMachine.transition(deepFlatParallelMachine.initialState, 'a');
            var state2 = deepFlatParallelMachine.transition(state1, 'c');
            var state3 = deepFlatParallelMachine.transition(state2, 'b');
            assert.deepEqual(state3.value, {
                V: {
                    B: {
                        BB: {
                            BBB_A: {},
                            BBB_B: {}
                        }
                    }
                },
                X: {}
            });
        });
        it('should not overlap resolved state trees in state resolution', function () {
            var machine = Machine({
                id: 'pipeline',
                type: 'parallel',
                states: {
                    foo: {
                        on: {
                            UPDATE: {
                                actions: function () {
                                    /* do nothing */
                                }
                            }
                        }
                    },
                    bar: {
                        on: {
                            UPDATE: '.baz'
                        },
                        initial: 'idle',
                        states: {
                            idle: {},
                            baz: {}
                        }
                    }
                }
            });
            assert.doesNotThrow(function () {
                machine.transition(machine.initialState, 'UPDATE');
            });
        });
    });
    describe('other', function () {
        // https://github.com/davidkpiano/xstate/issues/518
        it('regions should be able to transition to orthogonal regions', function () {
            var testMachine = Machine({
                id: 'app',
                type: 'parallel',
                states: {
                    Pages: {
                        id: 'Pages',
                        initial: 'About',
                        states: {
                            About: {
                                id: 'About',
                                on: {
                                    dashboard: '#Dashboard'
                                }
                            },
                            Dashboard: {
                                id: 'Dashboard',
                                on: {
                                    about: '#About'
                                }
                            }
                        }
                    },
                    Menu: {
                        id: 'Menu',
                        initial: 'Closed',
                        states: {
                            Closed: {
                                id: 'Closed',
                                on: {
                                    toggle: '#Opened'
                                }
                            },
                            Opened: {
                                id: 'Opened',
                                on: {
                                    toggle: '#Closed',
                                    'go to dashboard': '#Dashboard'
                                }
                            }
                        }
                    }
                }
            });
            var openMenuState = testMachine.transition(testMachine.initialState, 'toggle');
            var dashboardState = testMachine.transition(openMenuState, 'go to dashboard');
            assert.isTrue(dashboardState.matches({ Menu: 'Opened', Pages: 'Dashboard' }));
        });
    });
});
//# sourceMappingURL=parallel.test.js.map