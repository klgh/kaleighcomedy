import { assert } from 'chai';
import { Scheduler } from '../src/scheduler';
describe('scheduler', function () {
    it('should process event only once', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        scheduler.schedule(function () {
            calledCount++;
        });
        var expectedCount = 1;
        assert.equal(calledCount, expectedCount);
    });
    it('should process more than one event', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        scheduler.schedule(function () {
            calledCount++;
            scheduler.schedule(function () {
                calledCount++;
            });
        });
        var expectedCount = 2;
        assert.equal(calledCount, expectedCount);
    });
    it('should process events in the same order they were hit', function () {
        var order = [];
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        scheduler.schedule(function () {
            order.push(1);
            scheduler.schedule(function () {
                order.push(2);
            });
            scheduler.schedule(function () {
                order.push(3);
                scheduler.schedule(function () {
                    order.push(5);
                });
            });
            scheduler.schedule(function () {
                order.push(4);
            });
        });
        var expectedOrder = [1, 2, 3, 4, 5];
        assert.equal(order.length, expectedOrder.length);
        for (var i = 0; i < expectedOrder.length; i++) {
            assert.equal(order[i], expectedOrder[i]);
        }
    });
    it('should recover if error is thrown while processing event', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        assert.throws(function () {
            return scheduler.schedule(function () {
                calledCount++;
                throw Error('Test');
            });
        }, 'Test');
        scheduler.schedule(function () {
            calledCount++;
        });
        var expectedCount = 2;
        assert.equal(calledCount, expectedCount);
    });
    it('should recover if error is thrown while processing the queue', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        assert.throws(function () {
            return scheduler.schedule(function () {
                calledCount++;
                scheduler.schedule(function () {
                    calledCount++;
                    throw Error('Test');
                });
            });
        }, 'Test');
        scheduler.schedule(function () {
            calledCount++;
        });
        var expectedCount = 3;
        assert.equal(calledCount, expectedCount);
    });
    it('should stop processing events if error condition is met', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        assert.throws(function () {
            return scheduler.schedule(function () {
                calledCount++;
                scheduler.schedule(function () {
                    calledCount++;
                    throw Error('Test');
                });
                scheduler.schedule(function () {
                    calledCount++;
                });
            });
        }, 'Test');
        var expectedCount = 2;
        assert.equal(calledCount, expectedCount);
    });
    it('should discard not processed events in the case of error condition', function () {
        var calledCount = 0;
        var scheduler = new Scheduler();
        scheduler.initialize(); // TODO: refactor (use .start())
        assert.throws(function () {
            return scheduler.schedule(function () {
                calledCount++;
                scheduler.schedule(function () {
                    calledCount++;
                    throw Error('Test');
                });
                scheduler.schedule(function () {
                    calledCount++;
                });
            });
        }, 'Test');
        scheduler.schedule(function () {
            calledCount++;
        });
        var expectedCount = 3;
        assert.equal(calledCount, expectedCount);
    });
    describe('deferred events', function () {
        it('should be able to defer events', function () {
            var calledCount = 0;
            var scheduler = new Scheduler({
                deferEvents: true
            });
            scheduler.schedule(function () {
                calledCount++;
            });
            var expectedCount = 0;
            assert.equal(calledCount, expectedCount);
            scheduler.initialize(); // TODO: refactor (use .start())
            var expectedFinalCount = 1;
            assert.equal(calledCount, expectedFinalCount);
        });
        it('should process initialization before other events', function () {
            var callOrder = [];
            var scheduler = new Scheduler({
                deferEvents: true
            });
            scheduler.schedule(function () {
                callOrder.push(2);
            });
            scheduler.schedule(function () {
                callOrder.push(3);
            });
            scheduler.initialize(function () {
                callOrder.push(1);
            });
            var expectedOrder = [1, 2, 3];
            assert.equal(callOrder.length, expectedOrder.length);
            for (var i = 0; i < expectedOrder.length; i++) {
                assert.equal(callOrder[i], expectedOrder[i]);
            }
        });
        it('should not defer events after initialization', function () {
            var scheduler = new Scheduler({
                deferEvents: true
            });
            scheduler.initialize(); // TODO: refactor (use .start())
            var calledCount = 0;
            scheduler.schedule(function () {
                calledCount++;
            });
            var expectedCount = 1;
            assert.equal(calledCount, expectedCount);
        });
    });
});
//# sourceMappingURL=scheduler.test.js.map