import { assert, use as chaiUse } from 'chai';
import { Machine } from '../src/index';
import { after, cancel, send, actionTypes } from '../src/actions';
// tslint:disable-next-line:no-var-requires
var chaiSubset = /*#__PURE__*/require('chai-subset');
chaiUse(chaiSubset);
var lightMachine = /*#__PURE__*/Machine({
    id: 'light',
    initial: 'green',
    context: {
        canTurnGreen: true
    },
    states: {
        green: {
            after: {
                1000: 'yellow'
            }
        },
        yellow: {
            after: {
                1000: [{ target: 'red' }]
            }
        },
        red: {
            after: [{ delay: 1000, target: 'green' }]
        }
    }
});
describe('delayed transitions', function () {
    it('should resolve transitions', function () {
        assert.containSubset(lightMachine.states.green.after, [{
            target: ['yellow'],
            delay: 1000,
            event: after(1000, 'light.green'),
            actions: []
        }]);
        assert.containSubset(lightMachine.states.yellow.after, [{
            target: ['red'],
            cond: undefined,
            delay: 1000,
            event: after(1000, 'light.yellow'),
            actions: []
        }]);
        assert.containSubset(lightMachine.states.red.after, [{
            target: ['green'],
            cond: undefined,
            delay: 1000,
            event: after(1000, 'light.red'),
            actions: []
        }]);
    });
    it('should transition after delay', function () {
        var nextState = lightMachine.transition(lightMachine.initialState, after(1000, 'light.green'));
        assert.deepEqual(nextState.value, 'yellow');
        assert.deepEqual(nextState.actions, [cancel(after(1000, 'light.green')), send(after(1000, 'light.yellow'), { delay: 1000 })]);
    });
    it('should format transitions properly', function () {
        var greenNode = lightMachine.states.green;
        var transitions = greenNode.transitions;
        assert.deepEqual(transitions.map(function (t) {
            return t.event;
        }), [after(1000, greenNode.id)]);
    });
    describe('delay expressions', function () {
        var delayExprMachine = Machine({
            id: 'delayExpr',
            initial: 'inactive',
            context: {
                delay: 1000
            },
            states: {
                inactive: {
                    after: [{
                        delay: function (ctx) {
                            return ctx.delay;
                        },
                        target: 'active'
                    }],
                    on: {
                        ACTIVATE: 'active',
                        NOEXPR: 'activeNoExpr'
                    }
                },
                active: {
                    after: [{
                        delay: 'someDelay',
                        target: 'inactive'
                    }]
                },
                activeNoExpr: {
                    after: [{
                        delay: 'nonExistantDelay',
                        target: 'inactive'
                    }]
                }
            }
        }, {
            delays: {
                someDelay: function (ctx, event) {
                    return ctx.delay + event.delay;
                }
            }
        });
        it('should evaluate the expression (function) to determine the delay', function () {
            var initialState = delayExprMachine.initialState;
            var sendActions = initialState.actions.filter(function (a) {
                return a.type === actionTypes.send;
            });
            assert.lengthOf(sendActions, 1);
            assert.equal(sendActions[0].delay, 1000);
        });
        it('should evaluate the expression (string) to determine the delay', function () {
            var initialState = delayExprMachine.initialState;
            var activeState = delayExprMachine.transition(initialState, {
                type: 'ACTIVATE',
                delay: 500
            });
            var sendActions = activeState.actions.filter(function (a) {
                return a.type === actionTypes.send;
            });
            assert.lengthOf(sendActions, 1);
            assert.equal(sendActions[0].delay, 1000 + 500);
        });
        it('should send the expression (string) as delay if expression not found', function () {
            var initialState = delayExprMachine.initialState;
            var activeState = delayExprMachine.transition(initialState, {
                type: 'NOEXPR',
                delay: 500
            });
            var sendActions = activeState.actions.filter(function (a) {
                return a.type === actionTypes.send;
            });
            assert.lengthOf(sendActions, 1);
            assert.equal(sendActions[0].delay, 'nonExistantDelay');
        });
    });
});
//# sourceMappingURL=after.test.js.map