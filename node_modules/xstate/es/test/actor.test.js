var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Machine, spawn, interpret } from '../src';
import { assign, send, sendParent, raise, doneInvoke, actionTypes } from '../src/actions';
import { assert } from 'chai';
import { interval } from 'rxjs';
import { map } from 'rxjs/operators';
describe('spawning machines', function () {
    var todoMachine = Machine({
        id: 'todo',
        initial: 'incomplete',
        states: {
            incomplete: {
                on: { SET_COMPLETE: 'complete' }
            },
            complete: {
                onEntry: sendParent({ type: 'TODO_COMPLETED' })
            }
        }
    });
    var context = {
        todoRefs: {}
    };
    var todosMachine = Machine({
        id: 'todos',
        context: context,
        initial: 'active',
        states: {
            active: {
                on: {
                    TODO_COMPLETED: 'success'
                }
            },
            success: {
                type: 'final'
            }
        },
        on: {
            ADD: {
                actions: assign({
                    todoRefs: function (ctx, e) {
                        var _a;
                        return __assign({}, ctx.todoRefs, (_a = {}, _a[e.id] = spawn(todoMachine), _a));
                    }
                })
            },
            SET_COMPLETE: {
                actions: send('SET_COMPLETE', {
                    to: function (ctx, e) {
                        return ctx.todoRefs[e.id];
                    }
                })
            }
        }
    });
    var serverMachine = Machine({
        id: 'server',
        initial: 'waitPing',
        states: {
            waitPing: {
                on: {
                    PING: 'sendPong'
                }
            },
            sendPong: {
                entry: [sendParent('PONG'), raise('SUCCESS')],
                on: {
                    SUCCESS: 'waitPing'
                }
            }
        }
    });
    var clientMachine = Machine({
        id: 'client',
        initial: 'init',
        context: {
            server: undefined
        },
        states: {
            init: {
                entry: [assign({
                    server: function () {
                        return spawn(serverMachine);
                    }
                }), raise('SUCCESS')],
                on: {
                    SUCCESS: 'sendPing'
                }
            },
            sendPing: {
                entry: [send('PING', { to: function (ctx) {
                        return ctx.server;
                    } }), raise('SUCCESS')],
                on: {
                    SUCCESS: 'waitPong'
                }
            },
            waitPong: {
                on: {
                    PONG: 'complete'
                }
            },
            complete: {
                type: 'final'
            }
        }
    });
    it('should invoke actors', function (done) {
        var service = interpret(todosMachine).onDone(function () {
            done();
        }).start();
        service.send('ADD', { id: 42 });
        service.send('SET_COMPLETE', { id: 42 });
    });
    it('should invoke a null actor if spawned outside of a service', function () {
        assert.ok(spawn(todoMachine));
    });
    it('should allow bidirectional communication between parent/child actors', function (done) {
        interpret(clientMachine).onDone(function () {
            done();
        }).start();
    });
});
describe('spawning promises', function () {
    var _a;
    var promiseMachine = Machine({
        id: 'promise',
        initial: 'idle',
        context: {
            promiseRef: undefined
        },
        states: {
            idle: {
                entry: assign({
                    promiseRef: function () {
                        var ref = spawn(new Promise(function (res) {
                            res('response');
                        }), 'my-promise');
                        return ref;
                    }
                }),
                on: (_a = {}, _a[doneInvoke('my-promise')] = {
                    target: 'success',
                    cond: function (_, e) {
                        return e.data === 'response';
                    }
                }, _a)
            },
            success: {
                type: 'final'
            }
        }
    });
    it('should be able to spawn a promise', function (done) {
        var promiseService = interpret(promiseMachine).onDone(function () {
            done();
        });
        promiseService.start();
    });
});
describe('spawning callbacks', function () {
    var callbackMachine = Machine({
        id: 'callback',
        initial: 'idle',
        context: {
            callbackRef: undefined
        },
        states: {
            idle: {
                entry: assign({
                    callbackRef: function () {
                        return spawn(function (cb, receive) {
                            receive(function (event) {
                                if (event.type === 'START') {
                                    setTimeout(function () {
                                        cb('SEND_BACK');
                                    }, 10);
                                }
                            });
                        });
                    }
                }),
                on: {
                    START_CB: { actions: send('START', { to: function (ctx) {
                                return ctx.callbackRef;
                            } }) },
                    SEND_BACK: 'success'
                }
            },
            success: {
                type: 'final'
            }
        }
    });
    it('should be able to spawn an actor from a callback', function (done) {
        var callbackService = interpret(callbackMachine).onDone(function () {
            done();
        });
        callbackService.start();
        callbackService.send('START_CB');
    });
});
describe('spawning observables', function () {
    var observableMachine = Machine({
        id: 'observable',
        initial: 'idle',
        context: {
            observableRef: undefined
        },
        states: {
            idle: {
                entry: assign({
                    observableRef: function () {
                        var ref = spawn(interval(10).pipe(map(function (n) {
                            return {
                                type: 'INT',
                                value: n
                            };
                        })));
                        return ref;
                    }
                }),
                on: {
                    INT: {
                        target: 'success',
                        cond: function (_, e) {
                            return e.value === 5;
                        }
                    }
                }
            },
            success: {
                type: 'final'
            }
        }
    });
    it('should be able to spawn an observable', function (done) {
        var observableService = interpret(observableMachine).onDone(function () {
            done();
        });
        observableService.start();
    });
});
describe('actors', function () {
    it('should only spawn actors defined on initial state once', function () {
        var count = 0;
        var startMachine = Machine({
            id: 'start',
            initial: 'start',
            context: {
                items: [0, 1, 2, 3],
                refs: []
            },
            states: {
                start: {
                    entry: assign({
                        refs: function (ctx) {
                            count++;
                            var c = ctx.items.map(function (item) {
                                return spawn(new Promise(function (res) {
                                    return res(item);
                                }));
                            });
                            return c;
                        }
                    })
                }
            }
        });
        interpret(startMachine).onTransition(function () {
            assert.equal(count, 1);
        }).start();
    });
    it('should spawn null actors if not used within a service', function () {
        var nullActorMachine = Machine({
            initial: 'foo',
            context: { ref: undefined },
            states: {
                foo: {
                    entry: assign({
                        ref: function () {
                            return spawn(Promise.resolve(42));
                        }
                    })
                }
            }
        });
        var initialState = nullActorMachine.initialState;
        // assert.equal(initialState.context.ref!.id, 'null'); // TODO: identify null actors
        assert.isDefined(initialState.context.ref.send);
    });
    describe('autoForward option', function () {
        var pongActorMachine = Machine({
            id: 'server',
            initial: 'waitPing',
            states: {
                waitPing: {
                    on: {
                        PING: 'sendPong'
                    }
                },
                sendPong: {
                    entry: [sendParent('PONG'), raise('SUCCESS')],
                    on: {
                        SUCCESS: 'waitPing'
                    }
                }
            }
        });
        it('should not forward events to a spawned actor by default', function () {
            var pongCounter = 0;
            var machine = Machine({
                id: 'client',
                context: { counter: 0, serverRef: undefined },
                initial: 'initial',
                states: {
                    initial: {
                        entry: assign(function () {
                            return {
                                serverRef: spawn(pongActorMachine)
                            };
                        }),
                        on: {
                            PONG: {
                                actions: function () {
                                    return ++pongCounter;
                                }
                            }
                        }
                    }
                }
            });
            var service = interpret(machine);
            service.start();
            service.send('PING');
            service.send('PING');
            assert.equal(pongCounter, 0);
        });
        it('should not forward events to a spawned actor when { autoForward: false }', function () {
            var pongCounter = 0;
            var machine = Machine({
                id: 'client',
                context: { counter: 0, serverRef: undefined },
                initial: 'initial',
                states: {
                    initial: {
                        entry: assign(function () {
                            return {
                                serverRef: spawn(pongActorMachine, { autoForward: false })
                            };
                        }),
                        on: {
                            PONG: {
                                actions: function () {
                                    return ++pongCounter;
                                }
                            }
                        }
                    }
                }
            });
            var service = interpret(machine);
            service.start();
            service.send('PING');
            service.send('PING');
            assert.equal(pongCounter, 0);
        });
        it('should forward events to a spawned actor when { autoForward: true }', function () {
            var pongCounter = 0;
            var machine = Machine({
                id: 'client',
                context: { counter: 0, serverRef: undefined },
                initial: 'initial',
                states: {
                    initial: {
                        entry: assign(function () {
                            return {
                                serverRef: spawn(pongActorMachine, { autoForward: true })
                            };
                        }),
                        on: {
                            PONG: {
                                actions: function () {
                                    return ++pongCounter;
                                }
                            }
                        }
                    }
                }
            });
            var service = interpret(machine);
            service.start();
            service.send('PING');
            service.send('PING');
            assert.equal(pongCounter, 2);
        });
    });
    describe('sync option', function () {
        var _a;
        var childMachine = Machine({
            id: 'child',
            context: { value: 0 },
            initial: 'active',
            states: {
                active: {
                    after: {
                        10: { actions: assign({ value: 42 }) }
                    }
                }
            }
        });
        var parentMachine = Machine({
            id: 'parent',
            context: {
                ref: undefined,
                refNoSync: undefined,
                refNoSyncDefault: undefined
            },
            initial: 'foo',
            states: {
                foo: {
                    entry: assign({
                        ref: function () {
                            return spawn(childMachine, { sync: true });
                        },
                        refNoSync: function () {
                            return spawn(childMachine, { sync: false });
                        },
                        refNoSyncDefault: function () {
                            return spawn(childMachine);
                        }
                    }),
                    on: {
                        '': {
                            target: 'success',
                            cond: function (ctx) {
                                assert.isDefined(ctx.ref.state);
                                return ctx.ref.state.context.value === 42;
                            }
                        },
                        CHECK_NO_SYNC: {
                            target: 'success',
                            cond: function (ctx) {
                                assert.isUndefined(ctx.refNoSync.state);
                                return !ctx.refNoSync.state;
                            }
                        },
                        CHECK_NO_SYNC_DEFAULT: {
                            target: 'success',
                            cond: function (ctx) {
                                assert.isUndefined(ctx.refNoSyncDefault.state);
                                return !ctx.refNoSyncDefault.state;
                            }
                        }
                    }
                },
                success: {
                    type: 'final'
                }
            },
            on: (_a = {}, _a[actionTypes.update] = {
                actions: assign({})
            }, _a)
        });
        it('should sync spawned actor state when { sync: true }', function (done) {
            var service = interpret(parentMachine, { id: 'a-service' }).onDone(function () {
                return done();
            });
            service.start();
        });
        xit('should not sync spawned actor state when { sync: false }', function (done) {
            var service = interpret(parentMachine, { id: 'b-service' }).onDone(function () {
                assert.isUndefined(service.state.context.refNoSync.state);
                done();
            });
            service.start();
            service.send('CHECK_NO_SYNC');
        });
        xit('should not sync spawned actor state (default)', function (done) {
            var service = interpret(parentMachine, { id: 'c-service' }).onDone(function () {
                assert.isUndefined(service.state.context.refNoSyncDefault.state);
                done();
            });
            service.start();
            service.send('CHECK_NO_SYNC_DEFAULT');
        });
        it('parent state should be changed if synced child actor update occurs', function (done) {
            var syncChildMachine = Machine({
                initial: 'active',
                states: {
                    active: {
                        after: { 500: 'inactive' }
                    },
                    inactive: {}
                }
            });
            var syncMachine = Machine({
                initial: 'same',
                context: {},
                states: {
                    same: {
                        entry: assign({
                            ref: function () {
                                return spawn(syncChildMachine, { sync: true });
                            }
                        })
                    }
                }
            });
            interpret(syncMachine).onTransition(function (state) {
                if (state.context.ref && state.context.ref.state.matches('inactive')) {
                    assert.isTrue(state.changed);
                    done();
                }
            }).start();
        });
        var falseSyncOptions = [{}, { sync: false }];
        falseSyncOptions.forEach(function (falseSyncOption) {
            it("parent state should NOT be changed regardless of unsynced child actor update (options: " + JSON.stringify(falseSyncOption) + ")", function (done) {
                var syncChildMachine = Machine({
                    initial: 'active',
                    states: {
                        active: {
                            after: { 10: 'inactive' }
                        },
                        inactive: {}
                    }
                });
                var syncMachine = Machine({
                    initial: 'same',
                    context: {},
                    states: {
                        same: {
                            entry: assign({
                                ref: function () {
                                    return spawn(syncChildMachine, falseSyncOption);
                                }
                            })
                        }
                    }
                });
                var service = interpret(syncMachine).onTransition(function (state) {
                    if (state.context.ref && state.context.ref.state.matches('inactive')) {
                        assert.isFalse(state.changed);
                    }
                }).start();
                setTimeout(function () {
                    assert.isTrue(service.state.context.ref.state.matches('inactive'));
                    done();
                }, 20);
            });
            it("parent state should be changed if unsynced child actor manually sends update event (options: " + JSON.stringify(falseSyncOption) + ")", function (done) {
                var syncChildMachine = Machine({
                    initial: 'active',
                    states: {
                        active: {
                            after: { 10: 'inactive' }
                        },
                        inactive: {
                            entry: sendParent(actionTypes.update)
                        }
                    }
                });
                var syncMachine = Machine({
                    initial: 'same',
                    context: {},
                    states: {
                        same: {
                            entry: assign({
                                ref: function () {
                                    return spawn(syncChildMachine, falseSyncOption);
                                }
                            })
                        }
                    }
                });
                interpret(syncMachine).onTransition(function (state) {
                    if (state.context.ref && state.context.ref.state.matches('inactive')) {
                        assert.isTrue(state.changed);
                        done();
                    }
                }).start();
            });
        });
    });
});
//# sourceMappingURL=actor.test.js.map