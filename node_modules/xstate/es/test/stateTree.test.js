var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
import { StateTree } from '../src/StateTree';
import { Machine } from '../src';
import { assert } from 'chai';
var testMachine = /*#__PURE__*/Machine({
    id: 'test',
    initial: 'a',
    states: {
        a: {
            initial: 'one',
            states: {
                one: {},
                two: {
                    type: 'final'
                }
            }
        },
        b: {
            type: 'parallel',
            states: {
                one: {
                    initial: 'foo',
                    states: { foo: {}, bar: { type: 'final' } }
                },
                two: {
                    initial: 'foo',
                    states: {
                        foo: {
                            initial: 'x',
                            states: {
                                x: {}
                            }
                        },
                        bar: { type: 'final' }
                    }
                }
            }
        },
        c: {
            initial: 'one',
            states: {
                one: {
                    initial: 'aa',
                    states: {
                        aa: {
                            initial: 'foo',
                            states: { foo: {} }
                        },
                        bb: {
                            initial: 'foo',
                            states: { foo: {} }
                        },
                        cc: {}
                    }
                },
                two: {
                    initial: 'aa',
                    states: {
                        aa: {},
                        bb: {},
                        cc: {}
                    }
                },
                three: {
                    type: 'parallel',
                    states: {
                        aa: {
                            initial: 'aaa',
                            states: { aaa: {}, bbb: {} }
                        },
                        bb: {
                            initial: 'aaa',
                            states: { aaa: {}, bbb: {} }
                        }
                    }
                }
            }
        }
    }
});
describe('StateTree', function () {
    describe('.resolved', function () {
        it('represents the full value (compound)', function () {
            var st = new StateTree(testMachine, 'a').resolved;
            assert.deepEqual(st.value, { a: 'one' });
        });
        it('represents the full value (parallel)', function () {
            var st = new StateTree(testMachine, 'b').resolved;
            assert.deepEqual(st.value, {
                b: {
                    one: 'foo',
                    two: { foo: 'x' }
                }
            });
        });
        it('represents the full value (parallel deep)', function () {
            var st = new StateTree(testMachine, { b: 'two' }).resolved;
            assert.deepEqual(st.value, {
                b: {
                    one: 'foo',
                    two: { foo: 'x' }
                }
            });
        });
    });
    describe('.combine', function () {
        it('combines two state trees (compound)', function () {
            var st_c = new StateTree(testMachine, 'c');
            var st_c_two = new StateTree(testMachine, { c: 'two' });
            var combined = st_c.combine(st_c_two);
            assert.deepEqual(combined.value, { c: { two: {} } });
            assert.deepEqual(combined.resolved.value, { c: { two: 'aa' } });
        });
    });
    it('getEntryExitStates() should show correct entry/exit state nodes', function () {
        var st_A = new StateTree(testMachine, 'c').resolved; // { c: { one: 'aa' }}
        var st_B = new StateTree(testMachine, { c: { one: 'bb' } }).resolved;
        var res = st_B.getEntryExitStates(st_A);
        assert.deepEqual(__spread(res.exit).map(function (n) {
            return n.id;
        }), ['test.c.one.aa.foo', 'test.c.one.aa']);
        assert.deepEqual(__spread(res.entry).map(function (n) {
            return n.id;
        }), ['test.c.one.bb', 'test.c.one.bb.foo']);
    });
    it('only marks a tree as done when all parallel child nodes are in final states', function () {
        var myMachine = Machine({
            id: 'myId',
            type: 'parallel',
            states: {
                step1: {
                    initial: 'incomplete',
                    states: {
                        incomplete: { on: { FIRST_COMPLETE: 'complete' } },
                        complete: { type: 'final' }
                    }
                },
                step2: {
                    initial: 'incomplete',
                    states: {
                        incomplete: { on: { SECOND_COMPLETE: 'complete' } },
                        complete: { type: 'final' }
                    }
                }
            }
        });
        var firstCompleteState = myMachine.transition(myMachine.initialState, 'FIRST_COMPLETE');
        assert.isFalse(firstCompleteState.tree.done);
        var secondCompleteState = myMachine.transition(firstCompleteState, 'SECOND_COMPLETE');
        assert.isTrue(secondCompleteState.tree.done);
        // service.send('FIRST_COMPLETE')
        // expect(handleOnDone).not.toHaveBeenCalled()
    });
});
//# sourceMappingURL=stateTree.test.js.map