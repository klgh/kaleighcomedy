import { State, matchState, matchesState, Machine } from '../src';
import { assert } from 'chai';
describe('matchState()', function () {
    it('should match a value from a pattern with the state (simple)', function () {
        var simpleState = State.from('a', undefined);
        assert.ok(matchState(simpleState, [['b', function () {
            return false;
        }], ['a', function () {
            return true;
        }], [{ a: 'b' }, function () {
            return false;
        }]], function (_) {
            return false;
        }));
    });
    it('should match a value from a pattern with the state value', function () {
        assert.ok(matchState('a', [['b', function () {
            return false;
        }], ['a', function () {
            return true;
        }], [{ a: 'b' }, function () {
            return false;
        }]], function (_) {
            return false;
        }));
    });
    it('should match a value from a pattern with the state (compound)', function () {
        var simpleState = State.from({ a: 'b' }, undefined);
        assert.ok(matchState(simpleState, [['b', function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b' }, function () {
            return true;
        }], ['a', function () {
            return false;
        }]], function (_) {
            return false;
        }));
    });
    it('should match a value from a pattern with the state (compound, ancestor)', function () {
        var simpleState = State.from({ a: 'b' }, undefined);
        assert.ok(matchState(simpleState, [['b', function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], ['a', function () {
            return true;
        }], [{ a: 'b' }, function () {
            return false;
        }]], function (_) {
            return false;
        }));
    });
    it('should match a value from a pattern with the state (parallel)', function () {
        var simpleState = State.from({ a: 'b', c: { d: 'e', f: 'g' } }, undefined);
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], ['a', function () {
            return true;
        }], [{ a: 'b' }, function () {
            return false;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ a: 'b' }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ a: 'b', c: {} }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ a: 'b', c: { d: 'e' } }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ a: 'b', c: { d: 'e', f: 'g' } }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ c: {} }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ c: { d: 'e' } }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
        assert.ok(matchState(simpleState, [[{ a: {}, b: {} }, function () {
            return false;
        }], [{ a: { b: 'c' } }, function () {
            return false;
        }], [{ a: 'b', c: 'e' }, function () {
            return false;
        }], [{ c: { d: 'e', f: 'g' } }, function () {
            return true;
        }]], function (_) {
            return false;
        }));
    });
    it('should fallback to default if no pattern matched', function () {
        var simpleState = State.from('a', undefined);
        assert.ok(matchState(simpleState, [['b', function () {
            return false;
        }]], function (_) {
            return true;
        }));
    });
});
describe('matchesState()', function () {
    it('should return true if two states are equivalent', function () {
        assert.ok(matchesState('a', 'a'));
        assert.ok(matchesState('b.b1', 'b.b1'));
        assert.isFalse(matchesState('B.bar', { A: 'foo' }));
    });
    it('should return true if two state values are equivalent', function () {
        assert.ok(matchesState({ a: 'b' }, { a: 'b' }));
        assert.ok(matchesState({ a: { b: 'c' } }, { a: { b: 'c' } }));
    });
    it('should return true if two parallel states are equivalent', function () {
        assert.ok(matchesState({ a: { b1: 'foo', b2: 'bar' } }, { a: { b1: 'foo', b2: 'bar' } }));
        assert.ok(matchesState({ a: { b1: 'foo', b2: 'bar' }, b: { b3: 'baz', b4: 'quo' } }, { a: { b1: 'foo', b2: 'bar' }, b: { b3: 'baz', b4: 'quo' } }));
        assert.ok(matchesState({ a: 'foo', b: 'bar' }, { a: 'foo', b: 'bar' }));
    });
    it('should return true if a state is a substate of a superstate', function () {
        assert.ok(matchesState('b', 'b.b1'));
        assert.ok(matchesState('foo.bar', 'foo.bar.baz.quo'));
    });
    it('should return true if a state value is a substate of a superstate value', function () {
        assert.ok(matchesState('b', { b: 'b1' }));
        assert.ok(matchesState({ foo: 'bar' }, { foo: { bar: { baz: 'quo' } } }));
    });
    it('should return true if a parallel state value is a substate of a superstate value', function () {
        assert.ok(matchesState('b', { b: 'b1', c: 'c1' }));
        assert.ok(matchesState({ foo: 'bar', fooAgain: 'barAgain' }, { foo: { bar: { baz: 'quo' } }, fooAgain: { barAgain: 'baz' } }));
    });
    it('should return false if two states are not equivalent', function () {
        assert.ok(!matchesState('a', 'b'));
        assert.ok(!matchesState('a.a1', 'b.b1'));
    });
    it('should return false if parent state is more specific than child state', function () {
        assert.ok(!matchesState('a.b.c', 'a.b'));
        assert.ok(!matchesState({ a: { b: { c: 'd' } } }, { a: 'b' }));
    });
    it('should return false if two state values are not equivalent', function () {
        assert.ok(!matchesState({ a: 'a1' }, { b: 'b1' }));
    });
    it('should return false if a state is not a substate of a superstate', function () {
        assert.ok(!matchesState('a', 'b.b1'));
        assert.ok(!matchesState('foo.false.baz', 'foo.bar.baz.quo'));
    });
    it('should return false if a state value is not a substate of a superstate value', function () {
        assert.ok(!matchesState('a', { b: 'b1' }));
        assert.ok(!matchesState({ foo: { false: 'baz' } }, { foo: { bar: { baz: 'quo' } } }));
    });
    it('should mix/match string state values and object state values', function () {
        assert.ok(matchesState('a.b.c', { a: { b: 'c' } }));
    });
});
describe('matches() method', function () {
    it('should execute matchesState on a State given the parent state value', function () {
        var machine = Machine({
            initial: 'foo',
            states: {
                foo: {
                    initial: 'bar',
                    states: {
                        bar: {
                            initial: 'baz',
                            states: {
                                baz: {}
                            }
                        }
                    }
                }
            }
        });
        assert.ok(machine.initialState.matches('foo'));
        assert.ok(machine.initialState.matches({ foo: 'bar' }));
        assert.notOk(machine.initialState.matches('fake'));
    });
});
//# sourceMappingURL=match.test.js.map