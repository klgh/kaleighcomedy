import { interpret, Interpreter } from '../src/interpreter';
import { SimulatedClock } from '../src/SimulatedClock';
import { assert } from 'chai';
import { machine as idMachine } from './fixtures/id';
import { Machine, actions, assign, send, sendParent } from '../src';
import { State } from '../src/State';
import { log, actionTypes } from '../src/actions';
import { isObservable } from '../src/utils';
var lightMachine = /*#__PURE__*/Machine({
    id: 'light',
    initial: 'green',
    states: {
        green: {
            onEntry: [/*#__PURE__*/actions.send('TIMER', { delay: 10 })],
            on: {
                TIMER: 'yellow',
                KEEP_GOING: {
                    target: 'green',
                    actions: [/*#__PURE__*/actions.cancel('TIMER')],
                    internal: true
                }
            }
        },
        yellow: {
            onEntry: [/*#__PURE__*/actions.send('TIMER', { delay: 10 })],
            on: {
                TIMER: 'red'
            }
        },
        red: {
            after: {
                10: 'green'
            }
        }
    }
});
describe('interpreter', function () {
    it('creates an interpreter', function () {
        var service = interpret(idMachine);
        assert.instanceOf(service, Interpreter);
    });
    it('immediately notifies the listener with the initial state and event', function (done) {
        var service = interpret(idMachine).onTransition(function (initialState, event) {
            assert.instanceOf(initialState, State);
            assert.deepEqual(initialState.value, idMachine.initialState.value);
            assert.deepEqual(event.type, actionTypes.init);
            done();
        });
        service.start();
    });
    it('.initialState returns the initial state', function () {
        var service = interpret(idMachine);
        assert.deepEqual(service.initialState.value, idMachine.initialState.value);
    });
    describe('.nextState() method', function () {
        it('returns the next state for the given event without changing the interpreter state', function () {
            var state;
            var service = interpret(lightMachine, {
                clock: new SimulatedClock()
            }).onTransition(function (s) {
                state = s;
            }).start();
            var nextState = service.nextState('TIMER');
            assert.equal(nextState.value, 'yellow');
            assert.equal(state.value, 'green');
        });
    });
    describe('send with delay', function () {
        it('can send an event after a delay', function () {
            var currentStates = [];
            var listener = function (state) {
                currentStates.push(state);
                if (currentStates.length === 4) {
                    assert.deepEqual(currentStates.map(function (s) {
                        return s.value;
                    }), ['green', 'yellow', 'red', 'green']);
                }
            };
            var service = interpret(lightMachine, {
                clock: new SimulatedClock()
            }).onTransition(listener);
            var clock = service.clock;
            service.start();
            clock.increment(5);
            assert.equal(currentStates[0].value, 'green', 'State should still be green before delayed send');
            clock.increment(5);
            assert.deepEqual(currentStates.map(function (s) {
                return s.value;
            }), ['green', 'yellow']);
            clock.increment(5);
            assert.deepEqual(currentStates.map(function (s) {
                return s.value;
            }), ['green', 'yellow']);
            clock.increment(5);
            assert.deepEqual(currentStates.map(function (s) {
                return s.value;
            }), ['green', 'yellow', 'red']);
            clock.increment(5);
            assert.deepEqual(currentStates.map(function (s) {
                return s.value;
            }), ['green', 'yellow', 'red']);
            clock.increment(5);
            assert.deepEqual(currentStates.map(function (s) {
                return s.value;
            }), ['green', 'yellow', 'red', 'green']);
        });
        it('can send an event after a delay (expression)', function () {
            var delayExprMachine = Machine({
                id: 'delayExpr',
                context: {
                    initialDelay: 100
                },
                initial: 'idle',
                states: {
                    idle: {
                        on: {
                            ACTIVATE: 'pending'
                        }
                    },
                    pending: {
                        onEntry: send('FINISH', {
                            delay: function (ctx, e) {
                                return ctx.initialDelay + ('wait' in e ? e.wait : 0);
                            }
                        }),
                        on: {
                            FINISH: 'finished'
                        }
                    },
                    finished: { type: 'final' }
                }
            });
            var stopped = false;
            var clock = new SimulatedClock();
            var delayExprService = interpret(delayExprMachine, {
                clock: clock
            }).onDone(function () {
                stopped = true;
            }).start();
            delayExprService.send({
                type: 'ACTIVATE',
                wait: 50
            });
            clock.increment(101);
            assert.isFalse(stopped);
            clock.increment(50);
            assert.isTrue(stopped);
        });
        it('can send an event after a delay (delayed transitions)', function (done) {
            var clock = new SimulatedClock();
            var letterMachine = Machine({
                id: 'letter',
                context: {
                    delay: 100
                },
                initial: 'a',
                states: {
                    a: {
                        after: [{
                            delay: function (ctx) {
                                return ctx.delay;
                            },
                            target: 'b'
                        }]
                    },
                    b: {
                        after: {
                            someDelay: 'c'
                        }
                    },
                    c: {
                        onEntry: send({ type: 'FIRE_DELAY', value: 200 }, { delay: 20 }),
                        on: {
                            FIRE_DELAY: 'd'
                        }
                    },
                    d: {
                        after: [{
                            delay: function (ctx, e) {
                                return ctx.delay + e.value;
                            },
                            target: 'e'
                        }]
                    },
                    e: {
                        after: [{
                            delay: 'someDelay',
                            target: 'f'
                        }]
                    },
                    f: {
                        type: 'final'
                    }
                }
            }, {
                delays: {
                    someDelay: function (ctx) {
                        return ctx.delay + 50;
                    }
                }
            });
            var state;
            interpret(letterMachine, { clock: clock }).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                done();
            }).start();
            assert.equal(state.value, 'a');
            clock.increment(100);
            assert.equal(state.value, 'b');
            clock.increment(100 + 50);
            assert.equal(state.value, 'c');
            clock.increment(20);
            assert.equal(state.value, 'd');
            clock.increment(100 + 200);
            assert.equal(state.value, 'e');
            clock.increment(100 + 50);
        });
    });
    describe('activities', function () {
        var activityState = 'off';
        var activityMachine = Machine({
            id: 'activity',
            initial: 'on',
            states: {
                on: {
                    activities: 'myActivity',
                    on: {
                        TURN_OFF: 'off'
                    }
                },
                off: {}
            }
        }, {
            activities: {
                myActivity: function () {
                    activityState = 'on';
                    return function () {
                        return activityState = 'off';
                    };
                }
            }
        });
        it('should start activities', function () {
            var service = interpret(activityMachine);
            service.start();
            assert.equal(activityState, 'on');
        });
        it('should stop activities', function () {
            var service = interpret(activityMachine);
            service.start();
            assert.equal(activityState, 'on');
            service.send('TURN_OFF');
            assert.equal(activityState, 'off');
        });
        it('should stop activities upon stopping the service', function () {
            var stopActivityState;
            var stopActivityMachine = Machine({
                id: 'stopActivity',
                initial: 'on',
                states: {
                    on: {
                        activities: 'myActivity',
                        on: {
                            TURN_OFF: 'off'
                        }
                    },
                    off: {}
                }
            }, {
                activities: {
                    myActivity: function () {
                        stopActivityState = 'on';
                        return function () {
                            return stopActivityState = 'off';
                        };
                    }
                }
            });
            var stopActivityService = interpret(stopActivityMachine).start();
            assert.equal(stopActivityState, 'on');
            stopActivityService.stop();
            assert.equal(stopActivityState, 'off', 'activity should be disposed');
        });
        it('should not restart activities from a compound state', function () {
            var activityActive = false;
            var toggleMachine = Machine({
                id: 'toggle',
                initial: 'inactive',
                states: {
                    inactive: {
                        on: { TOGGLE: 'active' }
                    },
                    active: {
                        activities: 'blink',
                        on: { TOGGLE: 'inactive' },
                        initial: 'A',
                        states: {
                            A: { on: { SWITCH: 'B' } },
                            B: { on: { SWITCH: 'A' } }
                        }
                    }
                }
            }, {
                activities: {
                    blink: function () {
                        activityActive = true;
                        return function () {
                            activityActive = false;
                        };
                    }
                }
            });
            var activeState = toggleMachine.transition(toggleMachine.initialState, 'TOGGLE');
            var bState = toggleMachine.transition(activeState, 'SWITCH');
            var state;
            interpret(toggleMachine).onTransition(function (s) {
                state = s;
            }).start(bState);
            assert.ok(state.activities.blink);
            assert.isFalse(activityActive);
        });
    });
    it('can cancel a delayed event', function () {
        var currentState;
        var listener = function (state) {
            return currentState = state;
        };
        var service = interpret(lightMachine, {
            clock: new SimulatedClock()
        }).onTransition(listener);
        var clock = service.clock;
        service.start();
        clock.increment(5);
        service.send('KEEP_GOING');
        assert.deepEqual(currentState.value, 'green');
        clock.increment(10);
        assert.deepEqual(currentState.value, 'green', 'should still be green due to canceled event');
    });
    it('should throw an error if an event is sent to an uninitialized interpreter if { deferEvents: false }', function () {
        var service = interpret(lightMachine, {
            clock: new SimulatedClock(),
            deferEvents: false
        });
        assert.throws(function () {
            return service.send('SOME_EVENT');
        }, /uninitialized/);
        service.start();
        assert.doesNotThrow(function () {
            return service.send('SOME_EVENT');
        });
    });
    it('should not throw an error if an event is sent to an uninitialized interpreter if { deferEvents: true }', function () {
        var service = interpret(lightMachine, {
            clock: new SimulatedClock(),
            deferEvents: true
        });
        assert.doesNotThrow(function () {
            return service.send('SOME_EVENT');
        });
        service.start();
        assert.doesNotThrow(function () {
            return service.send('SOME_EVENT');
        });
    });
    it('should not throw an error if an event is sent to an uninitialized interpreter (default options)', function () {
        var service = interpret(lightMachine, {
            clock: new SimulatedClock()
        });
        assert.doesNotThrow(function () {
            return service.send('SOME_EVENT');
        });
        service.start();
        assert.doesNotThrow(function () {
            return service.send('SOME_EVENT');
        });
    });
    it('should defer events sent to an uninitialized service', function (done) {
        var deferMachine = Machine({
            id: 'defer',
            initial: 'a',
            states: {
                a: {
                    on: { NEXT_A: 'b' }
                },
                b: {
                    on: { NEXT_B: 'c' }
                },
                c: {
                    type: 'final'
                }
            }
        });
        var state;
        var deferService = interpret(deferMachine).onTransition(function (s) {
            state = s;
        }).onDone(function () {
            return done();
        });
        // uninitialized
        deferService.send('NEXT_A');
        deferService.send('NEXT_B');
        assert.isUndefined(state);
        // initialized
        deferService.start();
    });
    it('should throw an error if initial state sent to interpreter is invalid', function () {
        var invalidMachine = {
            id: 'fetchMachine',
            initial: 'create',
            states: {
                edit: {
                    initial: 'idle',
                    states: {
                        idle: {
                            on: {
                                FETCH: 'pending'
                            }
                        }
                    }
                }
            }
        };
        assert.throws(function () {
            interpret(Machine(invalidMachine)).start();
        }, "Initial state 'create' not found on 'fetchMachine'");
    });
    it('should not update when stopped', function () {
        var state = lightMachine.initialState;
        var service = interpret(lightMachine, {
            clock: new SimulatedClock()
        }).onTransition(function (s) {
            return state = s;
        });
        service.start();
        service.send('TIMER'); // yellow
        assert.deepEqual(state.value, 'yellow');
        service.stop();
        try {
            service.send('TIMER'); // red if interpreter is not stopped
        } catch (e) {
            assert.deepEqual(state.value, 'yellow');
        }
    });
    it('should be able to log (log action)', function () {
        var logs = [];
        var logMachine = Machine({
            id: 'log',
            initial: 'x',
            context: { count: 0 },
            states: {
                x: {
                    on: {
                        LOG: {
                            actions: [assign({ count: function (ctx) {
                                    return ctx.count + 1;
                                } }), log(function (ctx) {
                                return ctx;
                            })]
                        }
                    }
                }
            }
        });
        var service = interpret(logMachine, {
            logger: function (msg) {
                return logs.push(msg);
            }
        }).start();
        service.send('LOG');
        service.send('LOG');
        assert.lengthOf(logs, 2);
        assert.deepEqual(logs, [{ count: 1 }, { count: 2 }]);
    });
    describe('send() event expressions', function () {
        var machine = Machine({
            id: 'sendexpr',
            initial: 'start',
            context: {
                password: 'foo'
            },
            states: {
                start: {
                    onEntry: send(function (ctx) {
                        return { type: 'NEXT', password: ctx.password };
                    }),
                    on: {
                        NEXT: {
                            target: 'finish',
                            cond: function (_, e) {
                                return e.password === 'foo';
                            }
                        }
                    }
                },
                finish: {
                    type: 'final'
                }
            }
        });
        it('should resolve send event expressions', function (done) {
            interpret(machine).onDone(function () {
                return done();
            }).start();
        });
    });
    describe('sendParent() event expressions', function () {
        var childMachine = Machine({
            id: 'child',
            initial: 'start',
            context: {
                password: 'unknown'
            },
            states: {
                start: {
                    onEntry: sendParent(function (ctx) {
                        return { type: 'NEXT', password: ctx.password };
                    })
                }
            }
        });
        var parentMachine = Machine({
            id: 'parent',
            initial: 'start',
            states: {
                start: {
                    invoke: {
                        src: childMachine,
                        data: {
                            password: 'foo'
                        }
                    },
                    on: {
                        NEXT: {
                            target: 'finish',
                            cond: function (_, e) {
                                return e.password === 'foo';
                            }
                        }
                    }
                },
                finish: {
                    type: 'final'
                }
            }
        });
        it('should resolve sendParent event expressions', function (done) {
            interpret(parentMachine).onDone(function () {
                return done();
            }).start();
        });
    });
    describe('send() batch events', function () {
        var countMachine = Machine({
            id: 'count',
            initial: 'even',
            context: { count: 0 },
            states: {
                even: {
                    onExit: [assign({ count: function (ctx) {
                            return ctx.count + 1;
                        } }), 'evenAction'],
                    on: { INC: 'odd' }
                },
                odd: {
                    onExit: [assign({ count: function (ctx) {
                            return ctx.count + 1;
                        } }), 'oddAction'],
                    on: { INC: 'even' }
                }
            }
        });
        it('should batch send events', function (done) {
            var transitions = 0;
            var evenCounts = [];
            var oddCounts = [];
            var countService = interpret(countMachine.withConfig({
                actions: {
                    evenAction: function (ctx) {
                        evenCounts.push(ctx.count);
                    },
                    oddAction: function (ctx) {
                        oddCounts.push(ctx.count);
                    }
                }
            })).onTransition(function (state) {
                transitions++;
                switch (transitions) {
                    // initial state
                    case 1:
                        assert.deepEqual(state.context, { count: 0 });
                        break;
                    // transition with batched events
                    case 2:
                        assert.equal(state.value, 'even');
                        assert.deepEqual(state.context, { count: 4 });
                        assert.deepEqual(state.actions.map(function (a) {
                            return a.type;
                        }), ['evenAction', 'oddAction', 'evenAction', 'oddAction']);
                        assert.deepEqual(evenCounts, [1, 3], 'even actions should be bound to their state at time of creation');
                        assert.deepEqual(oddCounts, [2, 4], 'odd actions should be bound to their state at time of creation');
                        done();
                        break;
                }
            }).start();
            countService.send(['INC', 'INC', { type: 'INC' }, 'INC']);
        });
        it('state changed property should be true if any intermediate state is changed', function (done) {
            var transitions = 0;
            var countService = interpret(countMachine).onTransition(function (state) {
                transitions++;
                if (transitions === 2) {
                    assert.isTrue(state.changed);
                    done();
                }
            }).start();
            countService.send(['INC', 'bar']);
        });
        it('state changed property should be false if no intermediate state is changed', function (done) {
            var transitions = 0;
            var countService = interpret(countMachine).onTransition(function (state) {
                transitions++;
                if (transitions === 2) {
                    assert.isFalse(state.changed);
                    done();
                }
            }).start();
            countService.send(['foo', 'bar']);
        });
    });
    describe('send()', function () {
        var sendMachine = Machine({
            id: 'send',
            initial: 'inactive',
            states: {
                inactive: {
                    on: {
                        EVENT: {
                            target: 'active',
                            cond: function (_, e) {
                                return e.id === 42;
                            } // TODO: fix unknown event type
                        },
                        ACTIVATE: 'active'
                    }
                },
                active: {
                    type: 'final'
                }
            }
        });
        it('can send events with a string', function (done) {
            var service = interpret(sendMachine).onDone(function () {
                return done();
            }).start();
            service.send('ACTIVATE');
        });
        it('can send events with an object', function (done) {
            var service = interpret(sendMachine).onDone(function () {
                return done();
            }).start();
            service.send({ type: 'ACTIVATE' });
        });
        it('can send events with an object with payload', function (done) {
            var service = interpret(sendMachine).onDone(function () {
                return done();
            }).start();
            service.send({ type: 'EVENT', id: 42 });
        });
        it('can send events with a string and object payload', function (done) {
            var state;
            var service = interpret(sendMachine).onTransition(function (s) {
                state = s;
            }).onDone(function () {
                assert.deepEqual(state.event, { type: 'EVENT', id: 42 });
                done();
            }).start();
            service.send('EVENT', { id: 42 });
        });
        it('should receive and process all events sent simultaneously', function (done) {
            var toggleMachine = Machine({
                id: 'toggle',
                initial: 'inactive',
                states: {
                    fail: {},
                    inactive: {
                        on: {
                            INACTIVATE: 'fail',
                            ACTIVATE: 'active'
                        }
                    },
                    active: {
                        on: {
                            INACTIVATE: 'success'
                        }
                    },
                    success: {
                        type: 'final'
                    }
                }
            });
            var toggleService = interpret(toggleMachine).onDone(function () {
                done();
            }).start();
            toggleService.send('ACTIVATE');
            toggleService.send('INACTIVATE');
        });
    });
    describe('start()', function () {
        var startMachine = Machine({
            id: 'start',
            initial: 'foo',
            states: {
                foo: {
                    initial: 'one',
                    states: {
                        one: {}
                    }
                },
                bar: {}
            }
        });
        it('should initialize the service', function (done) {
            var state;
            var startService = interpret(startMachine).onTransition(function (s) {
                state = s;
                assert.isDefined(s);
                assert.deepEqual(s.value, startMachine.initialState.value);
                done();
            });
            assert.isUndefined(state);
            startService.start();
        });
        it('should not reinitialize a started service', function () {
            var stateCount = 0;
            var startService = interpret(startMachine).onTransition(function () {
                stateCount++;
            });
            startService.start();
            assert.equal(stateCount, 1);
            startService.start();
            assert.equal(stateCount, 1);
        });
        it('should be able to be initialized at a custom state', function (done) {
            var startService = interpret(startMachine).onTransition(function (state) {
                assert.ok(state.matches('bar'));
                done();
            });
            startService.start(State.from('bar'));
        });
        it('should be able to be initialized at a custom state value', function (done) {
            var startService = interpret(startMachine).onTransition(function (state) {
                assert.ok(state.matches('bar'));
                done();
            });
            startService.start('bar');
        });
        it('should be able to resolve a custom initialized state', function (done) {
            var startService = interpret(startMachine).onTransition(function (state) {
                assert.ok(state.matches({ foo: 'one' }));
                done();
            });
            startService.start(State.from('foo'));
        });
    });
    describe('stop()', function () {
        it('should cancel delayed events', function (done) {
            var called = false;
            var delayedMachine = Machine({
                id: 'delayed',
                initial: 'foo',
                states: {
                    foo: {
                        after: {
                            50: {
                                target: 'bar',
                                actions: function () {
                                    called = true;
                                }
                            }
                        }
                    },
                    bar: {}
                }
            });
            var delayedService = interpret(delayedMachine).start();
            delayedService.stop();
            setTimeout(function () {
                assert.isFalse(called);
                done();
            }, 60);
        });
    });
    describe('off()', function () {
        it('should remove transition listeners', function () {
            var toggleMachine = Machine({
                id: 'toggle',
                initial: 'inactive',
                states: {
                    inactive: {
                        on: { TOGGLE: 'active' }
                    },
                    active: {
                        on: { TOGGLE: 'inactive' }
                    }
                }
            });
            var toggleService = interpret(toggleMachine).start();
            var stateCount = 0;
            var listener = function () {
                return stateCount++;
            };
            toggleService.onTransition(listener);
            toggleService.send('TOGGLE');
            assert.equal(stateCount, 1);
            toggleService.send('TOGGLE');
            assert.equal(stateCount, 2);
            toggleService.off(listener);
            toggleService.send('TOGGLE');
            assert.equal(stateCount, 2);
        });
    });
    describe('options', function () {
        describe('execute', function () {
            it('should not execute actions if execute is false', function (done) {
                var effect = false;
                var machine = Machine({
                    id: 'noExecute',
                    initial: 'active',
                    states: {
                        active: {
                            type: 'final',
                            onEntry: function () {
                                effect = true;
                            }
                        }
                    }
                });
                interpret(machine, { execute: false }).onDone(function () {
                    assert.isFalse(effect);
                    done();
                }).start();
            });
            it('should not execute actions if execute is true (default)', function (done) {
                var effect = false;
                var machine = Machine({
                    id: 'noExecute',
                    initial: 'active',
                    states: {
                        active: {
                            type: 'final',
                            onEntry: function () {
                                effect = true;
                            }
                        }
                    }
                });
                interpret(machine, { execute: true }).onDone(function () {
                    assert.isTrue(effect);
                    done();
                }).start();
            });
            it('actions should be able to be executed manually with execute()', function (done) {
                var effect = false;
                var machine = Machine({
                    id: 'noExecute',
                    initial: 'active',
                    context: {
                        value: true
                    },
                    states: {
                        active: {
                            type: 'final',
                            onEntry: function (ctx) {
                                effect = ctx.value;
                            }
                        }
                    }
                });
                var service = interpret(machine, { execute: false }).onTransition(function (state) {
                    setTimeout(function () {
                        service.execute(state);
                        assert.isTrue(effect);
                        done();
                    }, 10);
                }).onDone(function () {
                    assert.isFalse(effect);
                }).start();
            });
            it('actions should be configurable with execute()', function (done) {
                var effect = false;
                var machine = Machine({
                    id: 'noExecute',
                    initial: 'active',
                    context: {
                        value: true
                    },
                    states: {
                        active: {
                            type: 'final',
                            onEntry: 'doEffect'
                        }
                    }
                });
                var service = interpret(machine, { execute: false }).onTransition(function (state) {
                    setTimeout(function () {
                        service.execute(state, {
                            doEffect: function (ctx) {
                                effect = ctx.value;
                            }
                        });
                        assert.isTrue(effect);
                        done();
                    }, 10);
                }).onDone(function () {
                    assert.isFalse(effect);
                }).start();
            });
        });
        describe('id', function () {
            it('uses the ID specified in the options', function () {
                var service = interpret(lightMachine, { id: 'custom-id' });
                assert.equal(service.id, 'custom-id');
            });
            it('uses the machine ID if not specified', function () {
                var service = interpret(lightMachine);
                assert.equal(service.id, lightMachine.id);
            });
        });
        describe('devTools', function () {
            it('devTools should not be connected by default', function () {
                var service = interpret(lightMachine);
                assert.isFalse(service.options.devTools);
            });
        });
    });
    describe('transient states', function () {
        it('should transition in correct order', function () {
            var stateMachine = Machine({
                id: 'transient',
                initial: 'idle',
                states: {
                    idle: { on: { START: 'transient' } },
                    transient: { on: { '': 'next' } },
                    next: { on: { FINISH: 'end' } },
                    end: { type: 'final' }
                }
            });
            var stateValues = [];
            var service = interpret(stateMachine).onTransition(function (current) {
                return stateValues.push(current.value);
            }).start();
            service.send('START');
            var expectedStateValues = ['idle', 'next'];
            assert.equal(stateValues.length, expectedStateValues.length);
            for (var i = 0; i < expectedStateValues.length; i++) {
                assert.equal(stateValues[i], expectedStateValues[i]);
            }
        });
        it('should transition in correct order when there is a condition', function () {
            var stateMachine = Machine({
                id: 'transient',
                initial: 'idle',
                states: {
                    idle: { on: { START: 'transient' } },
                    transient: {
                        on: {
                            '': [{ target: 'end', cond: 'alwaysFalse' }, { target: 'next' }]
                        }
                    },
                    next: { on: { FINISH: 'end' } },
                    end: { type: 'final' }
                }
            }, {
                guards: {
                    alwaysFalse: function () {
                        return false;
                    }
                }
            });
            var stateValues = [];
            var service = interpret(stateMachine).onTransition(function (current) {
                return stateValues.push(current.value);
            }).start();
            service.send('START');
            var expectedStateValues = ['idle', 'next'];
            assert.equal(stateValues.length, expectedStateValues.length);
            for (var i = 0; i < expectedStateValues.length; i++) {
                assert.equal(stateValues[i], expectedStateValues[i]);
            }
        });
    });
    describe('observable', function () {
        var context = { count: 0 };
        var intervalMachine = Machine({
            id: 'interval',
            context: context,
            initial: 'active',
            states: {
                active: {
                    after: {
                        10: {
                            target: 'active',
                            actions: assign({ count: function (ctx) {
                                    return ctx.count + 1;
                                } })
                        }
                    },
                    on: {
                        '': {
                            target: 'finished',
                            cond: function (ctx) {
                                return ctx.count >= 5;
                            }
                        }
                    }
                },
                finished: {
                    type: 'final'
                }
            }
        });
        it('should be subscribable', function (done) {
            var count;
            var intervalService = interpret(intervalMachine).start();
            intervalService.subscribe(function (state) {
                return count = state.context.count;
            }, undefined, function () {
                assert.equal(count, 5);
                done();
            });
        });
        it('should be unsubscribable', function (done) {
            var count;
            var intervalService = interpret(intervalMachine).start();
            assert.ok(isObservable(intervalService));
            var subscription = intervalService.subscribe(function (state) {
                return count = state.context.count;
            }, undefined, function () {
                assert.equal(count, 5);
                done();
            });
            setTimeout(function () {
                subscription.unsubscribe();
            }, 15);
            setTimeout(function () {
                assert.deepEqual(count, 1, 'count should not have advanced past 1');
                done();
            }, 500);
        });
    });
    describe('services', function () {
        it("doesn't crash cryptically on undefined return from the service creator", function () {
            var machine = Machine({
                initial: 'initial',
                states: {
                    initial: {
                        invoke: {
                            src: 'testService'
                        }
                    }
                }
            }, {
                services: {
                    testService: function () {
                        return void 0;
                    }
                }
            });
            var service = interpret(machine);
            assert.doesNotThrow(function () {
                return service.start();
            });
        });
    });
});
//# sourceMappingURL=interpreter.test.js.map