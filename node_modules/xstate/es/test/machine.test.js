var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { assert } from 'chai';
import { Machine, interpret } from '../src/index';
import { State } from '../src/State';
var pedestrianStates = {
    initial: 'walk',
    states: {
        walk: {
            on: {
                PED_COUNTDOWN: 'wait'
            }
        },
        wait: {
            on: {
                PED_COUNTDOWN: 'stop'
            }
        },
        stop: {}
    }
};
var lightMachine = /*#__PURE__*/Machine({
    key: 'light',
    initial: 'green',
    states: {
        green: {
            on: {
                TIMER: 'yellow',
                POWER_OUTAGE: 'red',
                FORBIDDEN_EVENT: undefined
            }
        },
        yellow: {
            on: {
                TIMER: 'red',
                POWER_OUTAGE: 'red'
            }
        },
        red: /*#__PURE__*/__assign({ on: {
                TIMER: 'green',
                POWER_OUTAGE: 'red'
            } }, pedestrianStates)
    }
});
var configMachine = /*#__PURE__*/Machine({
    id: 'config',
    initial: 'foo',
    context: {
        foo: 'bar'
    },
    states: {
        foo: {
            onEntry: 'entryAction',
            on: {
                EVENT: {
                    target: 'bar',
                    cond: 'someCondition'
                }
            }
        },
        bar: {}
    }
}, {
    actions: {
        entryAction: function () {
            throw new Error('original entry');
        }
    },
    guards: {
        someCondition: function () {
            return false;
        }
    }
});
describe('machine', function () {
    describe('machine.states', function () {
        it('should properly register machine states', function () {
            assert.deepEqual(Object.keys(lightMachine.states), ['green', 'yellow', 'red']);
        });
    });
    describe('machine.events', function () {
        it('should return the set of events accepted by machine', function () {
            assert.sameMembers(lightMachine.events, ['TIMER', 'POWER_OUTAGE', 'PED_COUNTDOWN']);
        });
    });
    describe('machine.initialState', function () {
        it('should return a State instance', function () {
            assert.instanceOf(lightMachine.initialState, State);
        });
        it('should return the initial state', function () {
            assert.equal(lightMachine.initialState.value, 'green');
        });
    });
    describe('machine.history', function () {
        it('should not retain previous history', function () {
            var next = lightMachine.transition(lightMachine.initialState, 'TIMER');
            var following = lightMachine.transition(next, 'TIMER');
            assert.isUndefined(following.history.history);
        });
    });
    describe('machine.withConfig', function () {
        it('should override guards and actions', function () {
            var differentMachine = configMachine.withConfig({
                actions: {
                    entryAction: function () {
                        throw new Error('new entry');
                    }
                },
                guards: { someCondition: function () {
                        return true;
                    } }
            });
            assert.deepEqual(differentMachine.context, { foo: 'bar' }, 'context should be untouched');
            var service = interpret(differentMachine);
            assert.throws(function () {
                return service.start();
            }, /new entry/, 'different action should be used');
            assert.deepEqual(differentMachine.transition('foo', 'EVENT').value, 'bar');
        });
        it('should not override context if not defined', function () {
            var differentMachine = configMachine.withConfig({});
            assert.deepEqual(differentMachine.initialState.context, configMachine.context);
        });
        it('should override context (second argument)', function () {
            var differentMachine = configMachine.withConfig({}, { foo: 'different' });
            assert.deepEqual(differentMachine.initialState.context, {
                foo: 'different'
            });
        });
    });
    describe('machine.resolveState()', function () {
        var resolveMachine = Machine({
            id: 'resolve',
            initial: 'foo',
            states: {
                foo: {
                    initial: 'one',
                    states: {
                        one: {
                            type: 'parallel',
                            states: {
                                a: {
                                    initial: 'aa',
                                    states: { aa: {} }
                                },
                                b: {
                                    initial: 'bb',
                                    states: { bb: {} }
                                }
                            },
                            on: {
                                TO_TWO: 'two'
                            }
                        },
                        two: {
                            on: { TO_ONE: 'one' }
                        }
                    },
                    on: {
                        TO_BAR: 'bar'
                    }
                },
                bar: {
                    on: {
                        TO_FOO: 'foo'
                    }
                }
            }
        });
        it('should resolve the state value', function () {
            var tempState = State.from('foo');
            var resolvedState = resolveMachine.resolveState(tempState);
            assert.deepEqual(resolvedState.value, {
                foo: { one: { a: 'aa', b: 'bb' } }
            });
        });
        it('should resolve the state tree (implicit via events)', function () {
            var tempState = State.from('foo');
            var resolvedState = resolveMachine.resolveState(tempState);
            assert.deepEqual(resolvedState.nextEvents, ['TO_BAR']);
        });
    });
    describe('versioning', function () {
        it('should allow a version to be specified', function () {
            var versionMachine = Machine({
                id: 'version',
                version: '1.0.4',
                states: {}
            });
            assert.equal(versionMachine.version, '1.0.4');
        });
        it('should show the version on state nodes', function () {
            var versionMachine = Machine({
                id: 'version',
                version: '1.0.4',
                states: {
                    foo: {
                        id: 'foo'
                    }
                }
            });
            var fooStateNode = versionMachine.getStateNodeById('foo');
            assert.equal(fooStateNode.version, '1.0.4');
        });
    });
    describe('id', function () {
        it('should represent the ID', function () {
            var idMachine = Machine({
                id: 'some-id',
                initial: 'idle',
                states: { idle: {} }
            });
            assert.equal(idMachine.id, 'some-id');
        });
        it('should represent the ID (state node)', function () {
            var idMachine = Machine({
                id: 'some-id',
                initial: 'idle',
                states: {
                    idle: {
                        id: 'idle'
                    }
                }
            });
            assert.equal(idMachine.getStateNode('idle').id, 'idle');
        });
        it('should use the key as the ID if no ID is provided', function () {
            var noIDMachine = Machine({
                key: 'some-key',
                initial: 'idle',
                states: { idle: {} }
            });
            assert.equal(noIDMachine.id, 'some-key');
        });
        it('should use the key as the ID if no ID is provided (state node)', function () {
            var noStateNodeIDMachine = Machine({
                id: 'some-id',
                initial: 'idle',
                states: { idle: {} }
            });
            assert.equal(noStateNodeIDMachine.getStateNode('idle').id, 'some-id.idle');
        });
    });
});
describe('StateNode', function () {
    it('should list transitions', function () {
        var greenNode = lightMachine.states.green;
        var transitions = greenNode.transitions;
        assert.deepEqual(transitions.map(function (t) {
            return t.event;
        }), ['TIMER', 'POWER_OUTAGE', 'FORBIDDEN_EVENT']);
    });
});
//# sourceMappingURL=machine.test.js.map